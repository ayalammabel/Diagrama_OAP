<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Organigramas OAP – Antes / Después</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    :root{ --accent:#16a34a; }
    body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fff}
    header{padding:16px 20px;border-bottom:1px solid #eee;background:#fff;position:sticky;top:0;z-index:10}
    h1{font-size:1.25rem;margin:0 0 6px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .hint{color:#555}
    select,button{padding:8px 10px;border:1px solid #d6d9de;background:#fafafa;border-radius:8px;cursor:pointer}
    button.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    #network{height:80vh}

    body.mode-antes{ --accent:#2b6cb0; }
    body.mode-despues{ --accent:#16a34a; }
  </style>
</head>
<body class="mode-despues">
  <header>
    <div class="row">
      <h1 id="title">Organigramas – OAP</h1>
      <label>
        Equipo:
        <select id="teamSelect"></select>
      </label>
      <button id="btnAntes">Ver ANTES</button>
      <button id="btnDespues" class="active">Ver DESPUÉS</button>
    </div>
    <div class="hint">
      Clic en la <b>raíz</b> para plegar/desplegar roles. Clic en un <b>rol</b> para ver/ocultar la persona (y subroles).<br/>
      En <b>OAP</b>, clic en un equipo abre su subdiagrama; dentro del equipo, la <b>Jefa OAP</b> queda fija arriba.
    </div>
  </header>

  <div id="network"></div>

  <script>
    /********** Config **********/
    const TEAMS = ["oap","4p","gestion_conocimiento","administrativo","ti","mipg"];
    const TEAM_LABELS = { oap:"OAP General","4p":"4P",gestion_conocimiento:"Gestión del Conocimiento",administrativo:"Administrativo",ti:"TI",mipg:"MIPG" };
    let currentKey = "oap";

    // niveles (se reajustan si hay sticky root)
    let LV_ROOT = 0, LV_ROLE = 1, LV_CHILD = 2;

    let orgBefore = null, orgAfter = null;
    let MODE = "DESPUES";

    // info jefa
    let JEFA_LABEL = "Jefa OAP";
    let JEFA_PERSON = ""; // ej. "Paola Rojas"
    const STICKY_ID = "GLOBAL_OAP_JEFA";
    let TEAM_ROOT_ID = null;

    // líder detectado/forzado por JSON
    let LEADER_NODE_ID = null;

    // cache-buster para evitar JSON en caché
    const BUST = () => `v=${Date.now()}`;

    // ESPACIADO HORIZONTAL mínimo (px) entre hermanos visibles
    const MIN_GAP = 220;

    /********** vis-network **********/
    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();
    const container = document.getElementById("network");

    const EDGE_COLOR = '#cbd5e1';
    const options = {
      layout: { hierarchical: {
        enabled:true,
        direction:"UD",
        levelSeparation:110,     // vertical (moderado)
        nodeSpacing: 140,        // base; luego peinamos a mano
        parentCentralization:true,
        blockShifting:true,
        edgeMinimization:true,
        sortMethod:"hubsize"
      }},
      physics:false,
      nodes:{ shape:"box", margin:10, borderWidth:1, color:{ background:"#fff", border:"#9aa3af" } },
      edges:{ color:{ color: EDGE_COLOR }, smooth:{ enabled:true, type:"horizontal", roundness:0, forceDirection:"vertical" } },
      interaction:{ hover:true, selectable:true }
    };
    const network = new vis.Network(container, { nodes, edges }, options);

    const expandedRoot  = new Set();   // raíces con roles desplegados
    const openedPersons = new Set();   // id de nodos-persona visibles
    const openedSubroles = new Set();  // id de roles con subroles visibles

    /********** helpers **********/
    const accent = ()=> getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#16a34a';

    function cleanPhase(lbl){
      if(!lbl) return '';
      return lbl.replace(/\s*[-–]\s*(ANTES|DESPUÉS)\s*$/i,'')
                .replace(/\s*\((ANTES|DESPUÉS)\)\s*$/i,'')
                .trim();
    }
    function splitTitlePerson(lbl){
      if(!lbl) return {title:"", person:""};
      const base = cleanPhase(lbl);
      const m = base.match(/^(.+?)\s*[–-]\s*(.+)$/);
      return m ? { title:m[1].trim(), person:m[2].trim() } : { title:base, person:"" };
    }

    function applyTheme(){
      document.getElementById("btnAntes").classList.toggle('active', MODE==="ANTES");
      document.getElementById("btnDespues").classList.toggle('active', MODE!=="ANTES");
      document.body.classList.toggle('mode-antes', MODE==="ANTES");
      document.body.classList.toggle('mode-despues', MODE!=="ANTES");
    }

    function unlockAllPositions(){
      const all = nodes.get();
      nodes.update(all.map(n => ({ id:n.id, fixed:false })));
    }

    function clearAll(){
      nodes.clear(); edges.clear();
      expandedRoot.clear(); openedPersons.clear(); openedSubroles.clear();
    }

    function mountRootNode(id, label, level){
      nodes.add({ id, label, level, shape:"box", color:{ background:"#fff", border:accent() }, borderWidth:2 });
    }

    function addRoles(parentId, roles, childLevel){
      roles.forEach(r=>{
        if(!nodes.get(r.id)) nodes.add({ id:r.id, label:r.name, level:childLevel, shape:"box" });
        const eid = `${parentId}-${r.id}`;
        if(!edges.get(eid)) edges.add({ id:eid, from:parentId, to:r.id });
      });
      expandedRoot.add(parentId);
    }
    function removeRoles(parentId, roles){
      roles.forEach(r=>{
        const pid = `${r.id}_P`;
        if(openedPersons.has(pid)){ try{nodes.remove(pid);}catch{}; try{edges.remove(`${r.id}-${pid}`);}catch{}; openedPersons.delete(pid); }
        closeSubroles(r.id);
        try{ edges.remove(`${parentId}-${r.id}`);}catch{}
        try{ nodes.remove(r.id);}catch{}
      });
      expandedRoot.delete(parentId);
    }

    // —— PERSONAS (click) —— (👇 OJO: un nivel MÁS profundo)
    function togglePerson(role, parentLevel){
      if (!role.person || !role.person.trim()) return; // si no hay persona, no muestres nada
      const pid = `${role.id}_P`;
      const level = (parentLevel ?? LV_CHILD) + 1;
      if(openedPersons.has(pid)){
        try{nodes.remove(pid);}catch{}; try{edges.remove(`${role.id}-${pid}`);}catch{}; openedPersons.delete(pid);
      }else{
        const node = { id:pid, label:role.person.trim(), shape:"box", level, font:{ italics:true } };
        if(role.planta) node.color = { background:"#efe9ff", border:"#7a5cff" };
        nodes.add(node);
        edges.add({ id:`${role.id}-${pid}`, from:role.id, to:pid });
        openedPersons.add(pid);
      }
    }

    // heurísticas para ignorar rótulos de ayuda
    const isNoiseLabel = (s="") => /^\s*\(.*\)\s*$/.test(s) || /ver\s+analistas|varios\s+apoyos?/i.test(s);
    const isPersonLike = (sr) => (sr?.person && sr.person.trim()) || /nuevo\s+perfil|perfil\s+nuevo/i.test(sr?.name||"");

    // —— SUBROLES —— (👇 OJO: SIEMPRE nivel +1 respecto al rol)
    function toggleSubroles(roleId, arr, parentLevel){
      if(!arr || !arr.length) return;
      if(openedSubroles.has(roleId)){
        arr.forEach(sr=>{
          const rid = sr.id;
          const pid = `${rid}_P`;
          try{nodes.remove(rid);}catch{}; try{edges.remove(`${roleId}-${rid}`);}catch{}
          try{nodes.remove(pid);}catch{}; try{edges.remove(`${roleId}-${pid}`);}catch{}
        });
        openedSubroles.delete(roleId);
      }else{
        const level = (parentLevel ?? LV_CHILD) + 1;
        arr.forEach(sr=>{
          if(isNoiseLabel(sr.name)) return; // ignora "(ver analistas)" etc.
          if(isPersonLike(sr)){
            const label = (sr.person && sr.person.trim()) ? sr.person.trim() : "(por definir)";
            const pid = `${sr.id}_P`;
            if(!nodes.get(pid)) nodes.add({ id:pid, label, shape:"box", level, font:{ italics:true } });
            if(!edges.get(`${roleId}-${pid}`)) edges.add({ id:`${roleId}-${pid}`, from:roleId, to:pid });
          }else{
            if(!nodes.get(sr.id)) nodes.add({ id:sr.id, label:sr.name, shape:"box", level });
            if(!edges.get(`${roleId}-${sr.id}`)) edges.add({ id:`${roleId}-${sr.id}`, from:roleId, to:sr.id });
          }
        });
        openedSubroles.add(roleId);
      }
    }
    function closeSubroles(roleId){
      const arr = orgAfter?.subroles?.[roleId];
      if(!arr || !openedSubroles.has(roleId)) return;
      arr.forEach(sr=>{
        const rid = sr.id, pid = `${rid}_P`;
        try{nodes.remove(rid);}catch{}; try{edges.remove(`${roleId}-${rid}`);}catch{}
        try{nodes.remove(pid);}catch{}; try{edges.remove(`${roleId}-${pid}`);}catch{}
      });
      openedSubroles.delete(roleId);
    }

    // —— re-cablear bajo el LÍDER (si existe) —— (roles cuelgan del líder, subroles NO se tocan)
    function rewireUnderLeaderIfAny(rootId, roles){
      let leaderId = LEADER_NODE_ID;
      if(!leaderId){
        const cand = roles.find(r=>/^\s*l[ií]der\s*$/i.test(r.name));
        leaderId = cand?.id || null;
      }
      if(!leaderId || !nodes.get(leaderId)) return;

      nodes.update({ id: leaderId, level: LV_ROLE });
      roles.forEach(r=>{
        if(r.id === leaderId) return;
        try{ edges.remove(`${rootId}-${r.id}`); }catch{}
        nodes.update({ id: r.id, level: LV_CHILD });
        const eid = `${leaderId}-${r.id}`;
        if(!edges.get(eid)) edges.add({ id:eid, from: leaderId, to: r.id });
      });
    }

    /********** ESPACIADO HORIZONTAL **********/
    function childrenOf(parentId){
      return edges.get({
        filter: e => e.from === parentId
      }).map(e => e.to);
    }

    function spreadChildren(parentId, gap = MIN_GAP){
      // hijos visibles del padre
      const kids = childrenOf(parentId).filter(id => !!nodes.get(id));
      if(kids.length < 2) return;

      // x del padre y de los hijos actuales
      const p = network.getPositions([parentId])[parentId];
      const posKids = network.getPositions(kids);

      // orden actual por x
      kids.sort((a,b) => posKids[a].x - posKids[b].x);

      // centramos bajo el padre
      const total = (kids.length - 1) * gap;
      let startX = p.x - total / 2;

      const updates = [];
      kids.forEach((id, i) => {
        const targetX = Math.round(startX + i * gap);
        updates.push({ id, x: targetX, fixed: { x:true, y:false } }); // fijamos solo X
      });
      nodes.update(updates);
    }

    function spreadTop(){
      // raíz visible cuyos hijos queremos espaciar
      const root = (currentKey === "oap") ? (MODE==="ANTES" ? orgBefore.id : orgAfter.id)
                                          : TEAM_ROOT_ID;
      if (root) spreadChildren(root);

      // además, espaciar cada rol con subroles y/o personas abiertos
      openedSubroles.forEach(rid => spreadChildren(rid));
      // y cada rol al que se le haya abierto al menos una persona
      // (padre = id antes de sufijo "_P")
      const parents = new Set();
      openedPersons.forEach(pid => {
        const parent = pid.replace(/_P$/, '');
        if (nodes.get(parent)) parents.add(parent);
      });
      parents.forEach(rid => spreadChildren(rid));
    }

    /********** montajes **********/
    function mountOAPBefore(){
      MODE="ANTES"; applyTheme();
      clearAll(); unlockAllPositions();
      LV_ROOT=0; LV_ROLE=1; LV_CHILD=2;

      const {title, person} = splitTitlePerson(orgBefore.label);
      if(title) JEFA_LABEL = cleanPhase(title);
      if(person) JEFA_PERSON = person;

      mountRootNode(orgBefore.id, JEFA_LABEL, LV_ROOT);
      addRoles(orgBefore.id, orgBefore.roles, LV_ROLE);
      updateCountsUI();
      network.fit({animation:{duration:200}});
      setTimeout(spreadTop, 0);
      enrichCountsForOAP(orgAfter.roles);
    }
    function mountOAPAfter(){
      MODE="DESPUES"; applyTheme();
      clearAll(); unlockAllPositions();
      LV_ROOT=0; LV_ROLE=1; LV_CHILD=2;

      const {title, person} = splitTitlePerson(orgAfter.label);
      if(title) JEFA_LABEL = cleanPhase(title);
      if(person) JEFA_PERSON = person;

      mountRootNode(orgAfter.id, JEFA_LABEL, LV_ROOT);
      addRoles(orgAfter.id, orgAfter.roles, LV_ROLE);
      updateCountsUI();
      network.fit({animation:{duration:200}});
      setTimeout(spreadTop, 0);
      enrichCountsForOAP(orgAfter.roles);
    }

    function mountTeamBefore(){
      MODE="ANTES"; applyTheme();
      clearAll(); unlockAllPositions();
      LV_ROOT=0; const TEAM_LEVEL=1; LV_ROLE=2; LV_CHILD=3;

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountRootNode(STICKY_ID, JEFA_LABEL, LV_ROOT);
      nodes.add({ id:TEAM_ROOT_ID, label:cleanPhase(orgBefore.label), level:TEAM_LEVEL, shape:"box" });
      edges.add({ id:`${STICKY_ID}-${TEAM_ROOT_ID}`, from:STICKY_ID, to:TEAM_ROOT_ID });

      addRoles(TEAM_ROOT_ID, orgBefore.roles, LV_ROLE);
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, orgBefore.roles);
      updateCountsUI();
      network.fit({animation:{duration:200}});
      setTimeout(spreadTop, 0);
    }
    function mountTeamAfter(){
      MODE="DESPUES"; applyTheme();
      clearAll(); unlockAllPositions();
      LV_ROOT=0; const TEAM_LEVEL=1; LV_ROLE=2; LV_CHILD=3;

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountRootNode(STICKY_ID, JEFA_LABEL, LV_ROOT);
      nodes.add({ id:TEAM_ROOT_ID, label:cleanPhase(orgAfter.label), level:TEAM_LEVEL, shape:"box" });
      edges.add({ id:`${STICKY_ID}-${TEAM_ROOT_ID}`, from:STICKY_ID, to:TEAM_ROOT_ID });

      addRoles(TEAM_ROOT_ID, orgAfter.roles, LV_ROLE);
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, orgAfter.roles);
      updateCountsUI();
      network.fit({animation:{duration:200}});
      setTimeout(spreadTop, 0);
    }

    function updateCountsUI(){
      document.getElementById("btnAntes").textContent  = `Ver ANTES (${orgBefore?.roles?.length ?? 0})`;
      document.getElementById("btnDespues").textContent = `Ver DESPUÉS (${orgAfter?.roles?.length ?? 0})`;
    }

    // en OAP, etiqueta cada equipo con el número de roles del JSON
    async function enrichCountsForOAP(roles){
      if(currentKey !== "oap" || !roles) return;
      for(const r of roles){
        if(!r.route) continue;
        try{
          const res = await fetch(`data/${r.route}.json?${BUST()}`);
          const data = await res.json();
          const n = (data.after?.roles?.length ?? 0);
          const base = String(r.name).replace(/\s*\(\d+\)\s*$/,'').trim();
          nodes.update({ id:r.id, label:`${base} (${n})` });
        }catch(_){}
      }
    }

    /********** carga **********/
    async function loadTeam(key){
      try{
        const res = await fetch(`data/${key}.json?${BUST()}`);
        const data = await res.json();
        const prefix = key.toUpperCase();

        const beforeRoles = (data.before.roles || []).map(r => ({
          id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
        }));
        const afterRoles  = (data.after.roles  || []).map(r => ({
          id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
        }));

        const sub = {};
        if (data.after.subroles){
          for (const roleId in data.after.subroles){
            sub[`${prefix}_${roleId}`] = data.after.subroles[roleId].map(sr => ({
              id:`${prefix}_${sr.id}`, name:sr.name, person:sr.person||"", planta:!!sr.planta, route:sr.route||""
            }));
          }
        }

        // líder forzado por JSON (opcional)
        LEADER_NODE_ID = null;
        if(data.meta?.leaderId) LEADER_NODE_ID = `${prefix}_${data.meta.leaderId}`;

        orgBefore = { id:`ROOT_BEFORE_${prefix}`, label:data.before.label || `${data.meta?.equipo||key} – ANTES`, roles:beforeRoles };
        orgAfter  = { id:`ROOT_AFTER_${prefix}`,  label:data.after.label  || `${data.meta?.equipo||key} – DESPUÉS`, roles:afterRoles, subroles:sub };

        if(key==="oap"){
          const {title, person} = splitTitlePerson(orgAfter.label);
          if(title) JEFA_LABEL = cleanPhase(title);
          if(person) JEFA_PERSON = person;
        }

        const nice = TEAM_LABELS[key] || (data.meta?.equipo || key);
        document.getElementById("title").textContent = `Organigrama – ${nice}${data.meta?.titulo ? ` (${data.meta.titulo})` : ""}`;

        currentKey = key;
        document.getElementById("teamSelect").value = key;

        if(key==="oap") mountOAPAfter(); else mountTeamAfter();
      }catch(err){
        console.error(err);
        alert(`No pude cargar data/${key}.json`);
      }
    }

    /********** interacción **********/
    network.on("click", (p)=>{
      if(!p.nodes.length) return;
      const id = p.nodes[0];

      // OAP
      if(currentKey === "oap"){
        if(MODE==="ANTES"){
          if(id===orgBefore.id){
            expandedRoot.has(orgBefore.id) ? removeRoles(orgBefore.id, orgBefore.roles)
                                            : addRoles(orgBefore.id, orgBefore.roles, LV_ROLE);
            setTimeout(spreadTop, 0);
            return;
          }
          const role = orgBefore.roles.find(r=>r.id===id);
          if(!role) return;
          if(role.route) return loadTeam(role.route);
          togglePerson(role, LV_CHILD+0);
          setTimeout(() => { spreadChildren(role.id); }, 0);
        }else{
          if(id===orgAfter.id){
            expandedRoot.has(orgAfter.id) ? removeRoles(orgAfter.id, orgAfter.roles)
                                           : addRoles(orgAfter.id, orgAfter.roles, LV_ROLE);
            setTimeout(spreadTop, 0);
            return;
          }
          const role = orgAfter.roles.find(r=>r.id===id);
          if(!role) return;
          if(role.route) return loadTeam(role.route);
          togglePerson(role, LV_CHILD);
          toggleSubroles(role.id, orgAfter.subroles?.[role.id], LV_CHILD);
          setTimeout(() => { spreadChildren(role.id); spreadTop(); }, 0);
        }
        return;
      }

      // Equipo con sticky root
      const teamRoot = TEAM_ROOT_ID;
      if(MODE==="ANTES"){
        if(id===STICKY_ID){ togglePerson({ id:STICKY_ID, person:JEFA_PERSON, planta:true }, LV_ROOT); return; }

        if(LEADER_NODE_ID && id === LEADER_NODE_ID){
          if(expandedRoot.has(teamRoot)){
            removeRoles(teamRoot, orgBefore.roles);
          }else{
            addRoles(teamRoot, orgBefore.roles, LV_ROLE);
            rewireUnderLeaderIfAny(teamRoot, orgBefore.roles);
          }
          setTimeout(spreadTop, 0);
          return;
        }

        if(id===teamRoot){
          expandedRoot.has(teamRoot) ? removeRoles(teamRoot, orgBefore.roles)
                                     : (addRoles(teamRoot, orgBefore.roles, LV_ROLE), rewireUnderLeaderIfAny(teamRoot, orgBefore.roles));
          setTimeout(spreadTop, 0);
          return;
        }
        const role = orgBefore.roles.find(r=>r.id===id);
        if(role){ togglePerson(role, LV_CHILD); setTimeout(()=>{ spreadChildren(role.id); spreadTop(); },0); return; }
      }else{
        if(id===STICKY_ID){ togglePerson({ id:STICKY_ID, person:JEFA_PERSON, planta:true }, LV_ROOT); return; }

        if(LEADER_NODE_ID && id === LEADER_NODE_ID){
          if(expandedRoot.has(teamRoot)){
            removeRoles(teamRoot, orgAfter.roles);
          }else{
            addRoles(teamRoot, orgAfter.roles, LV_ROLE);
            rewireUnderLeaderIfAny(teamRoot, orgAfter.roles);
          }
          setTimeout(spreadTop, 0);
          return;
        }

        if(id===teamRoot){
          expandedRoot.has(teamRoot) ? removeRoles(teamRoot, orgAfter.roles)
                                     : (addRoles(teamRoot, orgAfter.roles, LV_ROLE), rewireUnderLeaderIfAny(teamRoot, orgAfter.roles));
          setTimeout(spreadTop, 0);
          return;
        }
        const role = orgAfter.roles.find(r=>r.id===id);
        if(role){
          togglePerson(role, LV_CHILD);
          toggleSubroles(role.id, orgAfter.subroles?.[role.id], LV_CHILD);
          setTimeout(()=>{ spreadChildren(role.id); spreadTop(); },0);
          return;
        }
      }
    });

    // selector & botones
    const sel = document.getElementById("teamSelect");
    sel.innerHTML = TEAMS.map(k=>`<option value="${k}">${TEAM_LABELS[k]||k.toUpperCase()}</option>`).join("");
    sel.value = currentKey;
    sel.addEventListener("change", e=>loadTeam(e.target.value));

    document.getElementById("btnAntes").onclick   = ()=>{ if(currentKey==="oap") mountOAPBefore(); else mountTeamBefore(); };
    document.getElementById("btnDespues").onclick = ()=>{ if(currentKey==="oap") mountOAPAfter();  else mountTeamAfter();  };

    // arranque
    loadTeam(currentKey);
  </script>
</body>
</html>





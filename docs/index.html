<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Organigramas OAP – Antes / Después</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    :root{ --accent:#16a34a; }
    *{box-sizing:border-box}
    body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fff;color:#111}
    header{padding:16px 20px;border-bottom:1px solid #eee;background:#fff;position:sticky;top:0;z-index:10}
    h1{font-size:1.1rem;margin:0 0 6px;font-weight:700}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .hint{color:#555;font-size:0.9rem}
    select,button{padding:8px 10px;border:1px solid #d6d9de;background:#fafafa;border-radius:8px;cursor:pointer}
    button.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    #network{height:80vh}
    .pill{padding:.1rem .5rem;border-radius:999px;background:#eef6ff;border:1px solid #cfe7ff;color:#1e40af;font-size:.8rem}

    body.mode-antes{ --accent:#2b6cb0; }
    body.mode-despues{ --accent:#16a34a; }
  </style>
</head>
<body class="mode-despues">
  <header>
    <div class="row">
      <h1 id="title">Organigramas – OAP</h1>
      <label>
        Equipo:
        <select id="teamSelect"></select>
      </label>
      <button id="btnAntes">Ver ANTES</button>
      <button id="btnDespues" class="active">Ver DESPUÉS</button>
      <span id="status" class="pill">Listo</span>
    </div>
    <div class="hint">
      Clic en la <b>raíz</b> para plegar/desplegar el primer nivel. Clic en un <b>rol</b> para ver/ocultar la persona (y subroles).<br/>
      En <b>OAP</b>, clic en un equipo abre su subdiagrama; dentro del equipo, la <b>Jefa OAP</b> queda fija arriba.
    </div>
  </header>

  <div id="network"></div>

  <script>
    /****************** CONFIG GENERAL ******************/
    const DATA_DIR = "data";
    const TEAMS = ["oap","4p","gestion_conocimiento","administrativo","ti","mipg"];
    const TEAM_LABELS = { oap:"OAP General","4p":"4P",gestion_conocimiento:"Gestión del Conocimiento",administrativo:"Administrativo",ti:"TI",mipg:"MIPG" };

    // Niveles: 0 Jefa | 1 Equipo | 2 Líder | 3 Otros roles | 4 Subroles | 5 Personas de subroles
    const LEVEL_Y_GAP = 130;
    const MIN_GAP = 300;

    let currentKey = "oap";
    let MODE = "DESPUÉS";
    let orgBefore = null, orgAfter = null;

    let JEFA_LABEL = "Jefa OAP";
    let JEFA_PERSON = "";
    const STICKY_ID = "GLOBAL_OAP_JEFA";
    let TEAM_ROOT_ID = null;
    let LEADER_NODE_ID = null;

    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();
    const container = document.getElementById("network");
    const statusEl = document.getElementById("status");

    const EDGE_COLOR = '#cbd5e1';
    function baseOptions(){
      return {
        layout: { hierarchical: {
          enabled:true,
          direction:"UD",
          levelSeparation: LEVEL_Y_GAP,
          nodeSpacing: MIN_GAP,
          parentCentralization:true,
          blockShifting:false,
          edgeMinimization:true,
          sortMethod:"directed"
        }},
        physics:false,
        nodes:{ shape:"box", margin:10, borderWidth:1, color:{ background:"#fff", border:"#9aa3af" }, font:{ multi:false } },
        edges:{ color:{ color: EDGE_COLOR }, smooth:{ enabled:true, type:"horizontal", roundness:0, forceDirection:"vertical" } },
        interaction:{ hover:true, selectable:true, dragNodes:false, zoomView:true, dragView:true }
      };
    }
    const network = new vis.Network(container, { nodes, edges }, baseOptions());

    const expandedRoot  = new Set();
    const openedPersons = new Set();
    const openedSubroles = new Set();

    /****************** HELPERS ******************/
    const accent = ()=> getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#16a34a';
    const cleanPhase = (lbl='') => lbl.replace(/\s*[-–]\s*(ANTES|DESPUÉS)\s*$/i,'').replace(/\s*\((ANTES|DESPUÉS)\)\s*$/i,'').trim();
    function splitTitlePerson(lbl){
      if(!lbl) return {title:"", person:""};
      const base = cleanPhase(lbl);
      const m = base.match(/^(.+?)\s*[–-]\s*(.+)$/);
      return m ? { title:m[1].trim(), person:m[2].trim() } : { title:base, person:"" };
    }
    function setStatus(msg){ statusEl.textContent = msg; }

    function clearAll(){
      nodes.clear(); edges.clear();
      expandedRoot.clear(); openedPersons.clear(); openedSubroles.clear();
    }

    function mountBox(id, label, level, extra={}){
      const base = { id, label, level, shape:"box", color:{ background:"#fff", border:"#9aa3af" }, borderWidth:1 };
      nodes.add(Object.assign(base, extra));
    }
    function addEdge(from, to){ const id = `${from}-${to}`; if(!edges.get(id)) edges.add({ id, from, to }); }
    function getLevel(nodeId){ const n = nodes.get(nodeId); return (n && typeof n.level === 'number') ? n.level : null; }

    // subroles de cualquier nodo (roles o subroles)
    function getSubrolesArr(data, nodeId){
      return (data && data.subroles && data.subroles[nodeId]) ? data.subroles[nodeId] : null;
    }

    /****************** COLAPSO RECURSIVO ******************/
    function removePerson(parentId){
      const pid = `${parentId}_P`;
      if (openedPersons.has(pid)){
        try{ nodes.remove(pid); }catch(_){}
        try{ edges.remove(`${parentId}-${pid}`); }catch(_){}
        openedPersons.delete(pid);
      }
    }
    function closeSubtree(nodeId, data){
      const children = getSubrolesArr(data, nodeId) || [];
      // cerrar descendientes primero
      children.forEach(ch => {
        closeSubtree(ch.id, data);
        removePerson(ch.id);
        try{ edges.remove(`${nodeId}-${ch.id}`);}catch(_){}
        try{ nodes.remove(ch.id);}catch(_){}
        openedSubroles.delete(ch.id);
      });
      openedSubroles.delete(nodeId);
    }

    /****************** ESPACIADO Y FIJACIÓN ******************/
    function applyVerticalByLevel(y0=0){
      const all = nodes.get();
      nodes.update(all.map(n => (typeof n.level==='number') ? { id:n.id, y: y0 + n.level*LEVEL_Y_GAP } : { id:n.id }));
    }
    function childrenOf(parentId){
      return edges.get({ filter: e => e.from === parentId }).map(e => e.to).filter(id => !!nodes.get(id));
    }
    function spreadChildren(parentId, gap = MIN_GAP){
      const kids = childrenOf(parentId); if(kids.length < 2) return;
      const p = network.getPositions([parentId])[parentId] || {x:0,y:0};
      const posKids = network.getPositions(kids);
      kids.sort((a,b) => (posKids[a]?.x || 0) - (posKids[b]?.x || 0));
      const total = (kids.length - 1) * gap; let startX = p.x - total / 2;
      nodes.update(kids.map((id, i) => ({ id, x: Math.round(startX + i * gap) })));
    }
    function applyHorizontalSpacingAll(gap=MIN_GAP){
      const parents = Array.from(new Set(edges.get().map(e => e.from)));
      parents.sort((a,b) => ((nodes.get(a)?.level||0) - (nodes.get(b)?.level||0)));
      parents.forEach(pid => spreadChildren(pid, gap));
    }
    function fixAllPositions(fix=true){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:fix, y:fix } }))); }
    function unfixAllPositions(){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:false, y:false } }))); }
    function stabilizeAndFit(anim=200){
      setStatus("Ajustando layout…");
      unfixAllPositions();
      applyVerticalByLevel(0);
      setTimeout(() => {
        applyHorizontalSpacingAll(MIN_GAP);
        setTimeout(() => {
          fixAllPositions(true);
          network.fit({ animation:{ duration: anim, easingFunction:"easeInOutQuad" } });
          setStatus("Listo");
        }, 0);
      }, 0);
    }

    /****************** PERSONAS / SUBROLES ******************/
    function togglePersonNode(roleId, personLabel, levelIfUnknown, planta=false){
      if(!personLabel || !String(personLabel).trim()) return;
      const pid = `${roleId}_P`;
      if(openedPersons.has(pid)){
        try{ nodes.remove(pid); }catch(_){}
        try{ edges.remove(`${roleId}-${pid}`); }catch(_){}
        openedPersons.delete(pid);
        return;
      }
      const roleLevel = getLevel(roleId);
      const personLevel = (roleLevel!=null ? roleLevel + 1 : (levelIfUnknown || 3));
      const extra = { font:{ italics:true } };
      if(planta) extra.color = { background:"#efe9ff", border:"#7a5cff" };
      mountBox(pid, String(personLabel).trim(), personLevel, extra);
      addEdge(roleId, pid);
      openedPersons.add(pid);
    }

    // Solo crea persona placeholder si el subrol NO es contenedor
    function toggleSubroles(roleId, subrolesArr, dataCtx){
      if(!subrolesArr || !subrolesArr.length) return;

      if(openedSubroles.has(roleId)){
        subrolesArr.forEach(sr=>{
          const rid = sr.id, pid = `${rid}_P`;
          try{ nodes.remove(pid); }catch(_){}
          try{ edges.remove(`${rid}-${pid}`);}catch(_){}
          try{ nodes.remove(rid); }catch(_){}
          try{ edges.remove(`${roleId}-${rid}`);}catch(_){}
          openedPersons.delete(pid);
        });
        openedSubroles.delete(roleId);
        return;
      }

      const roleLevel = getLevel(roleId) ?? 3;
      const subLevel = roleLevel + 1;
      const personLevel = subLevel + 1;

      subrolesArr.forEach(sr=>{
        mountBox(sr.id, sr.name, subLevel);
        addEdge(roleId, sr.id);

        const hasGrandkids = !!getSubrolesArr(dataCtx, sr.id)?.length;

        if (sr.person && sr.person.trim()){
          mountBox(`${sr.id}_P`, sr.person.trim(), personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`);
          openedPersons.add(`${sr.id}_P`);
        } else if (!hasGrandkids) {
          mountBox(`${sr.id}_P`, "Nuevo perfil", personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`);
          openedPersons.add(`${sr.id}_P`);
        }
      });
      openedSubroles.add(roleId);
    }

    /****************** LÍDER ******************/
    function rewireUnderLeaderIfAny(rootId, roles, leaderIdFromMeta){
      let leaderId = leaderIdFromMeta || null;
      if(!leaderId){
        const cand = roles.find(r=>/^\s*l[ií]der\s*$/i.test(r.name));
        leaderId = cand?.id || null;
      }
      if(!leaderId || !nodes.get(leaderId)) return;

      nodes.update({ id: leaderId, level: 2 });
      roles.forEach(r=>{
        if(r.id === leaderId) return;
        try{ edges.remove(`${rootId}-${r.id}`); }catch(_){}
        addEdge(leaderId, r.id);
        nodes.update({ id: r.id, level: 3 });
      });
    }

    /****************** CARGA Y MONTAJES ******************/
    function updateCountsUI(){
      document.getElementById("btnAntes").textContent  = `Ver ANTES (${orgBefore?.roles?.length ?? 0})`;
      document.getElementById("btnDespues").textContent = `Ver DESPUÉS (${orgAfter?.roles?.length ?? 0})`;
    }

    async function enrichCountsForOAP(roles){
      if(currentKey !== "oap" || !roles) return;
      for(const r of roles){
        if(!r.route) continue;
        try{
          const res = await fetch(`${DATA_DIR}/${r.route}.json?cb=${Date.now()}`);
          const data = await res.json();
          const n = (data.after?.roles?.length ?? 0);
          const base = String(r.name).replace(/\s*\(\d+\)\s*$/,'').trim();
          nodes.update({ id:r.id, label:`${base} (${n})` });
        }catch(_){}
      }
    }

    function baseNetworkOptions(){ network.setOptions(baseOptions()); }

    function mountOAP(view="DESPUÉS"){
      MODE = view; clearAll(); baseNetworkOptions();
      const data = (view==="ANTES") ? orgBefore : orgAfter;
      const {title, person} = splitTitlePerson(data.label);
      JEFA_LABEL = title || JEFA_LABEL; if(person) JEFA_PERSON = person;

      mountBox(data.id, JEFA_LABEL, 0, { color:{ background:"#fff", border:accent() }, borderWidth:2 });
      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, 1); addEdge(data.id, r.id); });

      updateCountsUI(); enrichCountsForOAP(data.roles); stabilizeAndFit(160);
    }

    function addCountsToNodes(data){
      if(!data || !data.subroles) return;
      for(const parentId in data.subroles){
        const node = nodes.get(parentId); if(!node) continue;
        const n = data.subroles[parentId].length;
        const base = String(node.label||"").replace(/\s*\(\d+\s+roles?\)\s*$/,'').trim();
        nodes.update({ id: parentId, label: `${base} (${n} roles)` });
      }
    }

    function mountTeam(view="DESPUÉS"){
      MODE = view; clearAll(); baseNetworkOptions();

      const data = (view==="ANTES") ? orgBefore : orgAfter;

      mountBox(STICKY_ID, JEFA_LABEL, 0, { color:{ background:"#fff", border:accent() }, borderWidth:2 });
      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountBox(TEAM_ROOT_ID, cleanPhase(data.label), 1); addEdge(STICKY_ID, TEAM_ROOT_ID);

      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, 2); addEdge(TEAM_ROOT_ID, r.id); });
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, LEADER_NODE_ID);
      addCountsToNodes(data);

      updateCountsUI(); stabilizeAndFit(160);
    }

    async function loadTeam(key){
      setStatus("Cargando…");
      try{
        const res = await fetch(`${DATA_DIR}/${key}.json?cb=${Date.now()}`);
        const data = await res.json();
        const prefix = key.toUpperCase();

        function mapRoles(block){
          return (block.roles || []).map(r => ({
            id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
          }));
        }
        function mapSubroles(block){
          const out = {};
          if(block.subroles){
            for(const roleId in block.subroles){
              out[`${prefix}_${roleId}`] = block.subroles[roleId].map(sr=>({
                id:`${prefix}_${sr.id}`, name:sr.name, person:sr.person||"", planta:!!sr.planta
              }));
            }
          }
          return out;
        }

        LEADER_NODE_ID = data.meta?.leaderId ? `${prefix}_${data.meta.leaderId}` : null;

        orgBefore = { id:`ROOT_BEFORE_${prefix}`, label:data.before.label || `${data.meta?.equipo||key} – ANTES`, roles: mapRoles(data.before), subroles: mapSubroles(data.before) };
        orgAfter  = { id:`ROOT_AFTER_${prefix}`,  label:data.after.label  || `${data.meta?.equipo||key} – DESPUÉS`, roles: mapRoles(data.after),  subroles: mapSubroles(data.after) };

        if(key==="oap"){
          const {title, person} = splitTitlePerson(orgAfter.label);
          if(title) JEFA_LABEL = cleanPhase(title);
          if(person) JEFA_PERSON = person;
        }

        const nice = TEAM_LABELS[key] || (data.meta?.equipo || key);
        document.getElementById("title").textContent = `Organigrama – ${nice}${data.meta?.titulo ? ` (${data.meta.titulo})` : ""}`;

        currentKey = key; document.getElementById("teamSelect").value = key;
        if(key==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS");
        setStatus("Listo");
      }catch(err){
        console.error(err);
        setStatus("Error al cargar");
        alert(`No pude cargar ${DATA_DIR}/${key}.json`);
      }
    }

    /****************** INTERACCIÓN ******************/
    network.on("click", (p)=>{
      if(!p.nodes.length) return;
      const id = p.nodes[0];

      // Vista OAP
      if(currentKey === "oap"){
        const data = (MODE==="ANTES") ? orgBefore : orgAfter;

        if(id===data.id){
          if(expandedRoot.has(data.id)){
            (data.roles||[]).forEach(r=>{
              closeSubtree(r.id, data);
              removePerson(r.id);
              try{ edges.remove(`${data.id}-${r.id}`);}catch(_){}
              try{ nodes.remove(r.id);}catch(_){}
            });
            expandedRoot.delete(data.id); stabilizeAndFit(120); return;
          }else{
            (data.roles||[]).forEach(r=>{ if(!nodes.get(r.id)) mountBox(r.id, r.name, 1); addEdge(data.id, r.id); });
            expandedRoot.add(data.id); stabilizeAndFit(120); return;
          }
        }

        const role = (data.roles||[]).find(r=>r.id===id);
        if(role && role.route){ loadTeam(role.route); return; }
        if(role && !role.route){ nodes.update({ id: role.id, level: 2 }); togglePersonNode(role.id, role.person, 3, !!role.planta); stabilizeAndFit(120); }
        return;
      }

      // Vista de equipo
      const data = (MODE==="ANTES") ? orgBefore : orgAfter;

      if(id===STICKY_ID){ togglePersonNode(STICKY_ID, JEFA_PERSON, 1, true); stabilizeAndFit(120); return; }

      if(id===TEAM_ROOT_ID){
        if(expandedRoot.has(TEAM_ROOT_ID)){
          (data.roles||[]).forEach(r=>{
            closeSubtree(r.id, data);
            removePerson(r.id);
            try{ edges.remove(`${TEAM_ROOT_ID}-${r.id}`);}catch(_){}
            try{ nodes.remove(r.id);}catch(_){}
          });
          expandedRoot.delete(TEAM_ROOT_ID); stabilizeAndFit(120);
        }else{
          (data.roles||[]).forEach(r=>{ if(!nodes.get(r.id)) mountBox(r.id, r.name, 2); addEdge(TEAM_ROOT_ID, r.id); });
          rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, LEADER_NODE_ID);
          expandedRoot.add(TEAM_ROOT_ID); stabilizeAndFit(120);
        }
        return;
      }

      // clic en rol de primer nivel (bajo equipo o bajo líder)
      const role = (data.roles||[]).find(r=>r.id===id);
      if(role){
        togglePersonNode(role.id, role.person, 3, !!role.planta);
        const arr = data.subroles?.[role.id];
        if(arr && arr.length) toggleSubroles(role.id, arr, data);
        stabilizeAndFit(120);
        return;
      }

      // abrir también nodos contenedores (SIMISIONAL, PANDORA, etc.)
      const nested = getSubrolesArr(data, id);
      if (nested && nested.length){
        toggleSubroles(id, nested, data);
        stabilizeAndFit(120);
        return;
      }
    });

    /****************** SELECTOR Y BOTONES ******************/
    const sel = document.getElementById("teamSelect");
    sel.innerHTML = TEAMS.map(k=>`<option value="${k}">${TEAM_LABELS[k]||k.toUpperCase()}</option>`).join("");
    sel.value = currentKey;
    sel.addEventListener("change", e=>loadTeam(e.target.value));

    document.getElementById("btnAntes").onclick   = ()=>{ if(currentKey==="oap") mountOAP("ANTES"); else mountTeam("ANTES"); };
    document.getElementById("btnDespues").onclick = ()=>{ if(currentKey==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS"); };

    /****************** INICIO ******************/
    loadTeam(currentKey);
  </script>
</body>
</html>





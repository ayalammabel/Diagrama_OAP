<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Organigramas OAP – Antes / Después</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    :root{ --accent:#16a34a; }
    body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fff}
    header{padding:16px 20px;border-bottom:1px solid #eee;background:#fff;position:sticky;top:0;z-index:10}
    h1{font-size:1.25rem;margin:0 0 6px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .hint{color:#555}
    select,button{padding:8px 10px;border:1px solid #d6d9de;background:#fafafa;border-radius:8px;cursor:pointer}
    button.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    #network{height:80vh}

    body.mode-antes{ --accent:#2b6cb0; }
    body.mode-despues{ --accent:#16a34a; }
  </style>
</head>
<body class="mode-despues">
  <header>
    <div class="row">
      <h1 id="title">Organigrama – OAP</h1>
      <label>
        Equipo:
        <select id="teamSelect"></select>
      </label>
      <button id="btnAntes">Ver ANTES</button>
      <button id="btnDespues" class="active">Ver DESPUÉS</button>
    </div>
    <div class="hint">
      Clic en la <b>raíz</b> para plegar/desplegar roles. Clic en un <b>rol</b> para ver/ocultar la persona (y subroles).<br/>
      En <b>OAP</b>, clic en un equipo abre su subdiagrama; dentro del equipo, la <b>Jefa OAP</b> queda fija arriba.
    </div>
  </header>

  <div id="network"></div>

  <script>
    /********** Config **********/
    const TEAMS = ["oap","4p","gestion_conocimiento","administrativo","ti","mipg"];
    const TEAM_LABELS = { oap:"OAP General","4p":"4P",gestion_conocimiento:"Gestión del Conocimiento",administrativo:"Administrativo",ti:"TI",mipg:"MIPG" };
    let currentKey = "oap";

    // Modo (antes/después)
    let MODE = "DESPUES";

    // Conjuntos para aperturas
    const expandedRoot  = new Set();   // raíces con roles desplegados
    const openedPersons = new Set();   // nodos-persona abiertos
    const openedSubroles = new Set();  // roles con subroles abiertos

    // Estructuras en memoria del equipo cargado
    let orgBefore = null, orgAfter = null;

    // Datos “Jefa”
    let JEFA_LABEL = "Jefa OAP";
    let JEFA_PERSON = "";
    const STICKY_ID = "GLOBAL_OAP_JEFA";
    let TEAM_ROOT_ID = null;

    // Líder (opcional forzado por JSON)
    let LEADER_NODE_ID = null;

    // Para evitar caché
    const BUST = () => `v=${Date.now()}`;

    // ---- Parámetros de layout manual ----
    const MIN_GAP    = 220; // separación horizontal mínima (px) entre hojas
    const LEVEL_SEP  = 110; // separación vertical (px) entre niveles

    /********** vis-network **********/
    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();
    const container = document.getElementById("network");

    // Desactivamos layout jerárquico (haremos layout manual) y physics
    const options = {
      layout: { hierarchical: false },
      physics: { enabled: false },
      nodes:{
        shape:"box", margin:10, borderWidth:1,
        color:{ background:"#fff", border:"#9aa3af" }
      },
      edges:{
        color:{ color: '#cbd5e1' },
        smooth:{ enabled:true, type:"horizontal", roundness:0, forceDirection:"vertical" }
      },
      interaction:{ hover:true, selectable:true }
    };
    const network = new vis.Network(container, { nodes, edges }, options);

    /********** helpers **********/
    const accent = ()=> getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#16a34a';
    const isNoiseLabel = (s="") => /^\s*\(.*\)\s*$/.test(s) || /ver\s+analistas|varios\s+apoyos?/i.test(s);
    const isPersonLike = (sr) => (sr?.person && sr.person.trim()) || /nuevo\s+perfil|perfil\s+nuevo/i.test(sr?.name||"");

    function cleanPhase(lbl){
      if(!lbl) return '';
      return lbl.replace(/\s*[-–]\s*(ANTES|DESPUÉS)\s*$/i,'')
                .replace(/\s*\((ANTES|DESPUÉS)\)\s*$/i,'')
                .trim();
    }
    function splitTitlePerson(lbl){
      if(!lbl) return {title:"", person:""};
      const base = cleanPhase(lbl);
      const m = base.match(/^(.+?)\s*[–-]\s*(.+)$/);
      return m ? { title:m[1].trim(), person:m[2].trim() } : { title:base, person:"" };
    }
    function applyTheme(){
      document.getElementById("btnAntes").classList.toggle('active', MODE==="ANTES");
      document.getElementById("btnDespues").classList.toggle('active', MODE!=="ANTES");
      document.body.classList.toggle('mode-antes', MODE==="ANTES");
      document.body.classList.toggle('mode-despues', MODE!=="ANTES");
    }
    function clearAll(){
      nodes.clear(); edges.clear();
      expandedRoot.clear(); openedPersons.clear(); openedSubroles.clear();
    }
    function mountRootNode(id, label){
      nodes.add({ id, label, shape:"box", color:{ background:"#fff", border:accent() }, borderWidth:2 });
    }

    /********** utilidades de grafo **********/
    function childrenOf(parentId){
      // hijos visibles del grafo actual
      return edges.get({ filter: e => e.from === parentId }).map(e => e.to).filter(id => !!nodes.get(id));
    }
    function setPos(id, x, y){
      // fijamos completamente
      nodes.update({ id, x, y, fixed:{ x:true, y:true } });
    }

    /********** Layout manual tipo árbol **********/
    function computeSubtreeSize(id, memo = new Map()){
      if (memo.has(id)) return memo.get(id);
      const kids = childrenOf(id);
      if (kids.length === 0){
        memo.set(id, 1); // hoja visible => 1 “unidad”
        return 1;
      }
      let s = 0;
      for (const k of kids) s += computeSubtreeSize(k, memo);
      // Nunca menos de 1
      s = Math.max(1, s);
      memo.set(id, s);
      return s;
    }

    function layoutTree(id, leftX, depth, memo){
      // ancho total del subárbol en “unidades”
      const units = computeSubtreeSize(id, memo);
      const totalWidth = units * MIN_GAP;
      const xCenter = leftX + totalWidth / 2;
      const y = depth * LEVEL_SEP;
      setPos(id, xCenter, y);

      // hijos, cada uno ocupa ancho proporcional a su subárbol
      const kids = childrenOf(id);
      if (kids.length === 0) return;

      let cursor = leftX;
      for (const k of kids){
        const wUnits = computeSubtreeSize(k, memo);
        const w = wUnits * MIN_GAP;
        // posición del hijo = centro de su segmento
        layoutTree(k, cursor, depth + 1, memo);
        cursor += w;
      }
    }

    function relayout(){
      // Determinar raíz visible:
      // - En OAP: raíz = orgBefore.id u orgAfter.id
      // - En equipos: raíz = STICKY_ID (para incluir a la jefa)
      const root = (currentKey === "oap")
        ? (MODE === "ANTES" ? orgBefore.id : orgAfter.id)
        : STICKY_ID;

      if (!root || !nodes.get(root)) return;

      // Desbloquear posiciones antes de reubicar
      nodes.update(nodes.get().map(n => ({ id:n.id, fixed:false })));

      const memo = new Map();
      const totalUnits = computeSubtreeSize(root, memo);
      // arrancamos el layout a partir de X = 0 (network.fit centrará)
      layoutTree(root, 0, 0, memo);

      // encuadre
      network.fit({ animation: { duration: 200 } });
    }

    /********** altas/bajas de nodos **********/
    function addRoles(parentId, roles){
      roles.forEach(r=>{
        if(!nodes.get(r.id)) nodes.add({ id:r.id, label:r.name, shape:"box" });
        const eid = `${parentId}-${r.id}`;
        if(!edges.get(eid)) edges.add({ id:eid, from:parentId, to:r.id });
      });
      expandedRoot.add(parentId);
      relayout();
    }
    function removeRoles(parentId, roles){
      roles.forEach(r=>{
        const pid = `${r.id}_P`;
        if(openedPersons.has(pid)){
          try{nodes.remove(pid);}catch{}; try{edges.remove(`${r.id}-${pid}`);}catch{}; openedPersons.delete(pid);
        }
        closeSubroles(r.id);
        try{ edges.remove(`${parentId}-${r.id}`);}catch{}
        try{ nodes.remove(r.id);}catch{}
      });
      expandedRoot.delete(parentId);
      relayout();
    }

    // —— PERSONAS (click) —— (si hay persona, cuelga un nodo-hoja)
    function togglePerson(role){
      if (!role.person || !role.person.trim()) return;
      const pid = `${role.id}_P`;
      if(openedPersons.has(pid)){
        try{nodes.remove(pid);}catch{}; try{edges.remove(`${role.id}-${pid}`);}catch{}; openedPersons.delete(pid);
      }else{
        const node = { id:pid, label:role.person.trim(), shape:"box", font:{ italics:true } };
        if(role.planta) node.color = { background:"#efe9ff", border:"#7a5cff" };
        nodes.add(node);
        edges.add({ id:`${role.id}-${pid}`, from:role.id, to:pid });
        openedPersons.add(pid);
      }
      relayout();
    }

    function toggleSubroles(roleId, arr){
      if(!arr || !arr.length) return;
      if(openedSubroles.has(roleId)){
        arr.forEach(sr=>{
          const rid = sr.id;
          const pid = `${rid}_P`;
          try{nodes.remove(rid);}catch{}; try{edges.remove(`${roleId}-${rid}`);}catch{}
          try{nodes.remove(pid);}catch{}; try{edges.remove(`${roleId}-${pid}`);}catch{}
        });
        openedSubroles.delete(roleId);
      }else{
        arr.forEach(sr=>{
          if(isNoiseLabel(sr.name)) return;
          if(isPersonLike(sr)){
            const label = (sr.person && sr.person.trim()) ? sr.person.trim() : "Nuevo perfil";
            const pid = `${sr.id}_P`;
            if(!nodes.get(pid)) nodes.add({ id:pid, label, shape:"box", font:{ italics:true } });
            if(!edges.get(`${roleId}-${pid}`)) edges.add({ id:`${roleId}-${pid}`, from:roleId, to:pid });
          }else{
            if(!nodes.get(sr.id)) nodes.add({ id:sr.id, label:sr.name, shape:"box" });
            if(!edges.get(`${roleId}-${sr.id}`)) edges.add({ id:`${roleId}-${sr.id}`, from:roleId, to:sr.id });
          }
        });
        openedSubroles.add(roleId);
      }
      relayout();
    }
    function closeSubroles(roleId){
      const arr = orgAfter?.subroles?.[roleId];
      if(!arr || !openedSubroles.has(roleId)) return;
      arr.forEach(sr=>{
        const rid = sr.id, pid = `${rid}_P`;
        try{nodes.remove(rid);}catch{}; try{edges.remove(`${roleId}-${rid}`);}catch{}
        try{nodes.remove(pid);}catch{}; try{edges.remove(`${roleId}-${pid}`);}catch{}
      });
      openedSubroles.delete(roleId);
    }

    // —— Recolgar bajo LÍDER (si existe) ——
    function rewireUnderLeaderIfAny(rootId, roles){
      let leaderId = LEADER_NODE_ID;
      if(!leaderId){
        const cand = roles.find(r=>/^\s*l[ií]der\s*$/i.test(r.name));
        leaderId = cand?.id || null;
      }
      if(!leaderId || !nodes.get(leaderId)) return;

      roles.forEach(r=>{
        if(r.id === leaderId) return;
        const prevEdgeId = `${rootId}-${r.id}`;
        if (edges.get(prevEdgeId)) edges.remove(prevEdgeId);
        const eid = `${leaderId}-${r.id}`;
        if(!edges.get(eid)) edges.add({ id:eid, from: leaderId, to: r.id });
      });
    }

    /********** montajes **********/
    function mountOAPBefore(){
      MODE="ANTES"; applyTheme();
      clearAll();

      const {title, person} = splitTitlePerson(orgBefore.label);
      if(title) JEFA_LABEL = cleanPhase(title);
      if(person) JEFA_PERSON = person;

      mountRootNode(orgBefore.id, JEFA_LABEL);
      addRoles(orgBefore.id, orgBefore.roles);
      updateCountsUI();
      enrichCountsForOAP(orgAfter.roles);
    }
    function mountOAPAfter(){
      MODE="DESPUES"; applyTheme();
      clearAll();

      const {title, person} = splitTitlePerson(orgAfter.label);
      if(title) JEFA_LABEL = cleanPhase(title);
      if(person) JEFA_PERSON = person;

      mountRootNode(orgAfter.id, JEFA_LABEL);
      addRoles(orgAfter.id, orgAfter.roles);
      updateCountsUI();
      enrichCountsForOAP(orgAfter.roles);
    }

    function mountTeamBefore(){
      MODE="ANTES"; applyTheme();
      clearAll();

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      // Jefa
      mountRootNode(STICKY_ID, JEFA_LABEL);
      // Nodo del equipo
      nodes.add({ id:TEAM_ROOT_ID, label:cleanPhase(orgBefore.label), shape:"box" });
      edges.add({ id:`${STICKY_ID}-${TEAM_ROOT_ID}`, from:STICKY_ID, to:TEAM_ROOT_ID });

      addRoles(TEAM_ROOT_ID, orgBefore.roles);
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, orgBefore.roles);
    }
    function mountTeamAfter(){
      MODE="DESPUES"; applyTheme();
      clearAll();

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountRootNode(STICKY_ID, JEFA_LABEL);
      nodes.add({ id:TEAM_ROOT_ID, label:cleanPhase(orgAfter.label), shape:"box" });
      edges.add({ id:`${STICKY_ID}-${TEAM_ROOT_ID}`, from:STICKY_ID, to:TEAM_ROOT_ID });

      addRoles(TEAM_ROOT_ID, orgAfter.roles);
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, orgAfter.roles);
    }

    function updateCountsUI(){
      document.getElementById("btnAntes").textContent  = `Ver ANTES (${orgBefore?.roles?.length ?? 0})`;
      document.getElementById("btnDespues").textContent = `Ver DESPUÉS (${orgAfter?.roles?.length ?? 0})`;
    }

    // En OAP, etiqueta cada equipo con el número de roles “después”
    async function enrichCountsForOAP(roles){
      if(currentKey !== "oap" || !roles) return;
      for(const r of roles){
        if(!r.route) continue;
        try{
          const res = await fetch(`data/${r.route}.json?${BUST()}`);
          const data = await res.json();
          const n = (data.after?.roles?.length ?? 0);
          const base = String(r.name).replace(/\s*\(\d+\)\s*$/,'').trim();
          nodes.update({ id:r.id, label:`${base} (${n})` });
        }catch(_){}
      }
      relayout();
    }

    /********** carga **********/
    async function loadTeam(key){
      try{
        const res = await fetch(`data/${key}.json?${BUST()}`);
        const data = await res.json();
        const prefix = key.toUpperCase();

        const beforeRoles = (data.before.roles || []).map(r => ({
          id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
        }));
        const afterRoles  = (data.after.roles  || []).map(r => ({
          id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
        }));

        const sub = {};
        if (data.after.subroles){
          for (const roleId in data.after.subroles){
            sub[`${prefix}_${roleId}`] = data.after.subroles[roleId].map(sr => ({
              id:`${prefix}_${sr.id}`, name:sr.name, person:sr.person||"", planta:!!sr.planta, route:sr.route||""
            }));
          }
        }

        // líder forzado por JSON (opcional)
        LEADER_NODE_ID = null;
        if(data.meta?.leaderId) LEADER_NODE_ID = `${prefix}_${data.meta.leaderId}`;

        orgBefore = { id:`ROOT_BEFORE_${prefix}`, label:data.before.label || `${data.meta?.equipo||key} – ANTES`, roles:beforeRoles };
        orgAfter  = { id:`ROOT_AFTER_${prefix}`,  label:data.after.label  || `${data.meta?.equipo||key} – DESPUÉS`, roles:afterRoles, subroles:sub };

        if(key==="oap"){
          const {title, person} = splitTitlePerson(orgAfter.label);
          if(title) JEFA_LABEL = cleanPhase(title);
          if(person) JEFA_PERSON = person;
        }

        const nice = TEAM_LABELS[key] || (data.meta?.equipo || key);
        document.getElementById("title").textContent = `Organigrama – ${nice}${data.meta?.titulo ? ` (${data.meta.titulo})` : ""}`;

        currentKey = key;
        document.getElementById("teamSelect").value = key;

        if(key==="oap") mountOAPAfter(); else mountTeamAfter();
      }catch(err){
        console.error(err);
        alert(`No pude cargar data/${key}.json`);
      }
    }

    /********** interacción **********/
    network.on("click", (p)=>{
      if(!p.nodes.length) return;
      const id = p.nodes[0];

      // OAP
      if(currentKey === "oap"){
        if(MODE==="ANTES"){
          if(id===orgBefore.id){
            expandedRoot.has(orgBefore.id) ? removeRoles(orgBefore.id, orgBefore.roles)
                                            : addRoles(orgBefore.id, orgBefore.roles);
            return;
          }
          const role = orgBefore.roles.find(r=>r.id===id);
          if(!role) return;
          if(role.route) return loadTeam(role.route);
          return togglePerson(role);
        }else{
          if(id===orgAfter.id){
            expandedRoot.has(orgAfter.id) ? removeRoles(orgAfter.id, orgAfter.roles)
                                           : addRoles(orgAfter.id, orgAfter.roles);
            return;
          }
          const role = orgAfter.roles.find(r=>r.id===id);
          if(!role) return;
          if(role.route) return loadTeam(role.route);
          togglePerson(role);
          toggleSubroles(role.id, orgAfter.subroles?.[role.id]);
        }
        return;
      }

      // Equipo con “Jefa” arriba
      const teamRoot = TEAM_ROOT_ID;
      if(MODE==="ANTES"){
        if(id===STICKY_ID){ togglePerson({ id:STICKY_ID, person:JEFA_PERSON, planta:true }); return; }

        // Clic en LÍDER abre/cierra como el nodo del equipo
        if(LEADER_NODE_ID && id === LEADER_NODE_ID){
          if(expandedRoot.has(teamRoot)) removeRoles(teamRoot, orgBefore.roles);
          else { addRoles(teamRoot, orgBefore.roles); rewireUnderLeaderIfAny(teamRoot, orgBefore.roles); }
          return;
        }

        if(id===teamRoot){
          expandedRoot.has(teamRoot) ? removeRoles(teamRoot, orgBefore.roles)
                                     : (addRoles(teamRoot, orgBefore.roles), rewireUnderLeaderIfAny(teamRoot, orgBefore.roles));
          return;
        }
        const role = orgBefore.roles.find(r=>r.id===id);
        if(role){ togglePerson(role); return; }
      }else{
        if(id===STICKY_ID){ togglePerson({ id:STICKY_ID, person:JEFA_PERSON, planta:true }); return; }

        if(LEADER_NODE_ID && id === LEADER_NODE_ID){
          if(expandedRoot.has(teamRoot)) removeRoles(teamRoot, orgAfter.roles);
          else { addRoles(teamRoot, orgAfter.roles); rewireUnderLeaderIfAny(teamRoot, orgAfter.roles); }
          return;
        }

        if(id===teamRoot){
          expandedRoot.has(teamRoot) ? removeRoles(teamRoot, orgAfter.roles)
                                     : (addRoles(teamRoot, orgAfter.roles), rewireUnderLeaderIfAny(teamRoot, orgAfter.roles));
          return;
        }
        const role = orgAfter.roles.find(r=>r.id===id);
        if(role){
          togglePerson(role);
          toggleSubroles(role.id, orgAfter.subroles?.[role.id]);
          return;
        }
      }
    });

    // selector & botones
    const sel = document.getElementById("teamSelect");
    sel.innerHTML = TEAMS.map(k=>`<option value="${k}">${TEAM_LABELS[k]||k.toUpperCase()}</option>`).join("");
    sel.value = currentKey;
    sel.addEventListener("change", e=>loadTeam(e.target.value));

    document.getElementById("btnAntes").onclick   = ()=>{ if(currentKey==="oap") mountOAPBefore(); else mountTeamBefore(); };
    document.getElementById("btnDespues").onclick = ()=>{ if(currentKey==="oap") mountOAPAfter();  else mountTeamAfter();  };

    // arranque
    loadTeam(currentKey);
  </script>
</body>
</html>




<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Organigramas OAP – Antes / Después</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    :root{ --accent:#16a34a; }

    *{ box-sizing:border-box }
    body{ font-family:system-ui,Arial,sans-serif; margin:0; background:#fff; color:#111 }
    #network{ height:80vh }

    /* ===== App bar de presentación ===== */
    .appbar{
      --bg1:#f8fafc; --bg2:#eef2ff;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      border-bottom:1px solid #e5e7eb; padding:18px 22px 12px; position:sticky; top:0; z-index:10;
    }
    .appbar__top{ display:flex; align-items:flex-end; justify-content:space-between; gap:16px; flex-wrap:wrap; }
    .appbar__brand h1{ margin:0; font-weight:800; letter-spacing:.2px; font-size:1.25rem; }
    .subtitle{ margin:.25rem 0 0; color:#4b5563; font-size:.9rem }
    .appbar__controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    /* Select bonito */
    .select{ display:flex; gap:8px; align-items:center; color:#374151; font-weight:600; }
    .select select{
      appearance:none; -webkit-appearance:none; -moz-appearance:none;
      padding:8px 36px 8px 12px; border:1px solid #d1d5db; border-radius:10px; background:#fff
        url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 20 20"><path fill="%236b7280" d="M5.23 7.21a.75.75 0 0 1 1.06.02L10 11.06l3.71-3.83a.75.75 0 0 1 1.08 1.04l-4.25 4.38a.75.75 0 0 1-1.08 0L5.21 8.27a.75.75 0 0 1 .02-1.06z"/></svg>')
        no-repeat right 10px center;
      font-weight:600; color:#111827;
    }

    /* Botones segmentados ANTES / DESPUÉS */
    .segmented{ display:inline-flex; background:#fff; border:1px solid #d1d5db; border-radius:12px; overflow:hidden; box-shadow:0 1px 0 rgba(0,0,0,.03); }
    .segmented__btn{ border:0; background:transparent; padding:8px 12px; font-weight:700; cursor:pointer; color:#374151; }
    .segmented__btn:hover{ background:#f3f4f6; }
    .segmented__btn.active{ background:var(--accent); color:#fff; }

    /* Hint breve */
    .mini-hint{ margin:10px 0 0; color:#6b7280; font-size:.9rem }

    /* Toast de errores */
    .toast{
      position:fixed; right:16px; bottom:16px; max-width:60ch;
      background:#111827; color:#fff; padding:10px 12px; border-radius:10px;
      box-shadow:0 10px 24px rgba(0,0,0,.18); font-size:.9rem; opacity:0; transition:opacity .25s ease;
    }
    .toast.error{ background:#b91c1c; }
    .toast.show{ opacity:1; }

    /* Temas */
    body.mode-antes{ --accent:#2b6cb0; }
    body.mode-despues{ --accent:#16a34a; }
  </style>
</head>
<body class="mode-despues">
  <header class="appbar">
    <div class="appbar__top">
      <div class="appbar__brand">
        <h1 id="title">Transformación del equipo – OAP</h1>
        <p class="subtitle">Propuesta presentada por la Jefa OAP</p>
      </div>

      <div class="appbar__controls">
        <label class="select">
          <span>Equipo</span>
          <select id="teamSelect"></select>
        </label>

        <div class="segmented">
          <button id="btnAntes" class="segmented__btn">Antes</button>
          <button id="btnDespues" class="segmented__btn active">Después</button>
        </div>
      </div>
    </div>

    <p class="mini-hint">
      Clic en la <b>raíz</b> para abrir niveles. Clic en un <b>rol</b> para ver personas y subroles.
    </p>
  </header>

  <!-- Toast de errores -->
  <div id="toast" aria-live="polite" class="toast" hidden></div>

  <div id="network"></div>

  <script>
    /************ TOAST DE ERRORES ************/
    const toastEl = document.getElementById("toast");
    function showToast(message, type='error', ms=4200){
      if(!message) return;
      toastEl.textContent = message;
      toastEl.className = 'toast ' + (type || '');
      toastEl.hidden = false;
      requestAnimationFrame(()=> toastEl.classList.add('show'));
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>{
        toastEl.classList.remove('show');
        setTimeout(()=> toastEl.hidden = true, 250);
      }, ms);
    }
    // setStatus ahora solo muestra errores (para mantener la app bar limpia)
    function setStatus(msg){
      if (!msg) return;
      if (/error|fall|no pude/i.test(msg)) showToast(msg, 'error');
    }
    window.addEventListener("error", (e)=>{
      console.error(e.error || e.message);
      showToast("Error: " + (e.error?.message || e.message), 'error');
    });

    /************ CONFIG ************/
    const DATA_DIR = "data";
    const TEAMS = ["oap","4p","gestion_conocimiento","administrativo","ti","mipg"];
    const TEAM_LABELS = { oap:"OAP General","4p":"4P",gestion_conocimiento:"Gestión del Conocimiento",administrativo:"Administrativo",ti:"TI",mipg:"MIPG" };

    // Poblamos el selector pronto (si luego algo falla, el usuario sigue teniendo opciones)
    const sel = document.getElementById("teamSelect");
    sel.innerHTML = TEAMS.map(k=>`<option value="${k}">${TEAM_LABELS[k]||k.toUpperCase()}</option>`).join("");
    sel.value = "oap";

    // Niveles/espaciados
    const LEVEL_Y_GAP = 130;
    const MIN_GAP = 300;

    let currentKey = "oap";
    let MODE = "DESPUÉS";
    let orgBefore = null, orgAfter = null;

    let JEFA_LABEL = "Jefa OAP";
    let JEFA_PERSON = "";
    const STICKY_ID = "GLOBAL_OAP_JEFA";
    let TEAM_ROOT_ID = null;
    let LEADER_NODE_ID = null;

    const SIDE_OFFSET = 220;      // lateral genérico (líder)
    const JEFA_SIDE_OFFSET = 220; // lateral jefa

    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();
    const network = new vis.Network(
      document.getElementById("network"),
      { nodes, edges },
      baseOptions()
    );

    const expandedRoot  = new Set();
    const openedPersons = new Set();
    const openedSubroles = new Set();
    const sidePersons   = new Set();  // nodos laterales (jefa / líder)

    function baseOptions(){
      return {
        layout: { hierarchical: {
          enabled:true, direction:"UD",
          levelSeparation: LEVEL_Y_GAP, nodeSpacing: MIN_GAP,
          parentCentralization:true, blockShifting:false, edgeMinimization:true,
          sortMethod:"directed"
        }},
        physics:false,
        nodes:{ shape:"box", margin:10, borderWidth:1, color:{ background:"#fff", border:"#9aa3af" } },
        edges:{ color:{ color:'#cbd5e1' }, smooth:{ enabled:true, type:"horizontal", forceDirection:"vertical" } },
        interaction:{ hover:true, selectable:true, dragNodes:false, zoomView:true, dragView:true }
      };
    }

    /************ HELPERS ************/
    const accent = ()=> getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#16a34a';
    const cleanPhase = (lbl='') => lbl.replace(/\s*[-–]\s*(ANTES|DESPUÉS)\s*$/i,'').replace(/\s*\((ANTES|DESPUÉS)\)\s*$/i,'').trim();
    function splitTitlePerson(lbl){
      if(!lbl) return {title:"", person:""};
      const base = cleanPhase(lbl);
      const m = base.match(/^(.+?)\s*[–-]\s*(.+)$/);
      return m ? { title:m[1].trim(), person:m[2].trim() } : { title:base, person:"" };
    }

    function clearAll(){ nodes.clear(); edges.clear(); expandedRoot.clear(); openedPersons.clear(); openedSubroles.clear(); sidePersons.clear(); }
    function mountBox(id, label, level, extra={}){ nodes.add(Object.assign({ id, label, level, shape:"box", color:{ background:"#fff", border:"#9aa3af" }, borderWidth:1 }, extra)); }
    function addEdge(from, to){ const id = `${from}-${to}`; if(!edges.get(id)) edges.add({ id, from, to }); }
    function getLevel(nodeId){ const n = nodes.get(nodeId); return (n && typeof n.level === 'number') ? n.level : null; }
    function getSubrolesArr(data, nodeId){ return (data && data.subroles && data.subroles[nodeId]) ? data.subroles[nodeId] : null; }

    function removePerson(parentId){
      const pid = `${parentId}_P`;
      if (openedPersons.has(pid)){
        try{ nodes.remove(pid); }catch(_){}
        try{ edges.remove(`${parentId}-${pid}`); }catch(_){}
        openedPersons.delete(pid);
      }
    }
    function removeSidePerson(parentId){
      const sid = `${parentId}_S`;
      if (sidePersons.has(sid)){
        try{ nodes.remove(sid); }catch(_){}
        try{ edges.remove(`${parentId}-${sid}`); }catch(_){}
        sidePersons.delete(sid);
      }
    }
    function closeSubtree(nodeId, data){
      const children = getSubrolesArr(data, nodeId) || [];
      children.forEach(ch => {
        closeSubtree(ch.id, data);
        removePerson(ch.id);
        removeSidePerson(ch.id);
        try{ edges.remove(`${nodeId}-${ch.id}`);}catch(_){}
        try{ nodes.remove(ch.id);}catch(_){}
        openedSubroles.delete(ch.id);
      });
      openedSubroles.delete(nodeId);
    }

    // Lateral (para jefa / líder)
    function placeSidePersonFor(rootId, label, offset = SIDE_OFFSET){
      if (!label || !label.trim()) return;
      const sid = `${rootId}_S`;
      const rootNode = nodes.get(rootId); if(!rootNode) return;

      if (!nodes.get(sid)){
        mountBox(sid, label.trim(), rootNode.level, { font:{ italics:true } });
        addEdge(rootId, sid);
        try{ edges.update({ id:`${rootId}-${sid}`, dashes:true, arrows:'to', smooth:{ enabled:true, type:'horizontal' } }); }catch(_){}
        sidePersons.add(sid);
      }
      const r = network.getPositions([rootId])[rootId] || {x:0,y:0};
      nodes.update({ id: sid, x: r.x + offset, y: r.y, level: rootNode.level, fixed:{ x:true, y:true } });
    }
    function keepSideAligned(rootId, offset = SIDE_OFFSET){
      const sid = `${rootId}_S`;
      if (!nodes.get(sid) || !nodes.get(rootId)) return;
      const r = network.getPositions([rootId])[rootId];
      const level = getLevel(rootId) ?? 0;
      nodes.update({ id: sid, x: r.x + offset, y: r.y, level });
    }
    const placeSidePersonForJefa = (rootId)=> placeSidePersonFor(rootId, JEFA_PERSON, JEFA_SIDE_OFFSET);
    const keepJefaPersonSideAlignedFor = (rootId)=> keepSideAligned(rootId, JEFA_SIDE_OFFSET);

    function childrenOf(parentId){
      return edges.get({ filter: e => e.from === parentId }).map(e => e.to).filter(id => !!nodes.get(id));
    }
    function spreadChildren(parentId, gap = MIN_GAP){
      const kids = childrenOf(parentId); if(kids.length < 2) return;
      const p = network.getPositions([parentId])[parentId] || {x:0,y:0};
      const posKids = network.getPositions(kids);
      kids.sort((a,b) => (posKids[a]?.x || 0) - (posKids[b]?.x || 0));
      const total = (kids.length - 1) * gap; let startX = p.x - total / 2;
      nodes.update(kids.map((id, i) => ({ id, x: Math.round(startX + i * gap) })));
    }
    function applyHorizontalSpacingAll(gap=MIN_GAP){
      const parents = Array.from(new Set(edges.get().map(e => e.from)));
      parents.sort((a,b) => ((nodes.get(a)?.level||0) - (nodes.get(b)?.level||0)));
      parents.forEach(pid => spreadChildren(pid, gap));
    }
    function fixAllPositions(fix=true){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:fix, y:fix } }))); }
    function unfixAllPositions(){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:false, y:false } }))); }

    function stabilizeAndFit(anim=200){
      // No mostramos “ajustando/listo” para mantener la UI limpia
      unfixAllPositions();
      setTimeout(() => {
        applyHorizontalSpacingAll(MIN_GAP);
        if (currentKey === "oap") keepJefaPersonSideAlignedFor((MODE==="ANTES") ? orgBefore.id : orgAfter.id);
        else keepJefaPersonSideAlignedFor(STICKY_ID);
        Array.from(sidePersons).forEach(sid => keepSideAligned(sid.replace(/_S$/,''), SIDE_OFFSET));
        setTimeout(() => {
          fixAllPositions(true);
          network.fit({ animation:{ duration: anim, easingFunction:"easeInOutQuad" } });
        }, 0);
      }, 0);
    }

    function togglePersonNode(roleId, personLabel, levelIfUnknown, planta=false){
      const label = (personLabel || "").trim();
      if(!label) return;
      const pid = `${roleId}_P`;
      if(openedPersons.has(pid)){
        try{ nodes.remove(pid); }catch(_){}
        try{ edges.remove(`${roleId}-${pid}`); }catch(_){}
        openedPersons.delete(pid);
        return;
      }
      const roleLevel = getLevel(roleId);
      const personLevel = (roleLevel!=null ? roleLevel + 1 : (levelIfUnknown || 3));
      const extra = { font:{ italics:true } };
      if(planta) extra.color = { background:"#efe9ff", border:"#7a5cff" };
      mountBox(pid, label, personLevel, extra);
      addEdge(roleId, pid);
      openedPersons.add(pid);
    }

    function toggleSubroles(roleId, subrolesArr, dataCtx){
      if(!subrolesArr || !subrolesArr.length) return;

      if(openedSubroles.has(roleId)){
        subrolesArr.forEach(sr=>{
          const rid = sr.id, pid = `${rid}_P`;
          try{ nodes.remove(pid); }catch(_){}
          try{ edges.remove(`${rid}-${pid}`);}catch(_){}
          try{ nodes.remove(rid); }catch(_){}
          try{ edges.remove(`${roleId}-${rid}`);}catch(_){}
          openedPersons.delete(pid);
        });
        openedSubroles.delete(roleId);
        return;
      }

      const roleLevel = getLevel(roleId) ?? 3;
      const isLeaderParent = (LEADER_NODE_ID && roleId === LEADER_NODE_ID);
      const subLevel = roleLevel + (isLeaderParent ? 2 : 1);
      const personLevel = subLevel + 1;

      subrolesArr.forEach(sr=>{
        mountBox(sr.id, sr.name, subLevel);
        addEdge(roleId, sr.id);

        const hasGrandkids = !!getSubrolesArr(dataCtx, sr.id)?.length;
        const personText = (sr.person || "").trim();

        if (personText){
          mountBox(`${sr.id}_P`, personText, personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`); openedPersons.add(`${sr.id}_P`);
        } else if (!hasGrandkids) {
          mountBox(`${sr.id}_P`, "Nuevo perfil", personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`); openedPersons.add(`${sr.id}_P`);
        }
      });

      openedSubroles.add(roleId);
    }

    function rewireUnderLeaderIfAny(rootId, roles, leaderIdFromMeta){
      let leaderId = leaderIdFromMeta || null;
      if(!leaderId){
        const cand = roles.find(r=>/^\s*l[ií]der\s*$/i.test(r.name));
        leaderId = cand?.id || null;
      }
      if(!leaderId || !nodes.get(leaderId)) return;

      nodes.update({ id: leaderId, level: 2 });
      roles.forEach(r=>{
        if(r.id === leaderId) return;
        try{ edges.remove(`${rootId}-${r.id}`); }catch(_){}
        addEdge(leaderId, r.id);
        nodes.update({ id: r.id, level: 3 });
      });
    }

    function updateCountsUI(){
      document.getElementById("btnAntes").textContent  = `Antes (${orgBefore?.roles?.length ?? 0})`;
      document.getElementById("btnDespues").textContent = `Después (${orgAfter?.roles?.length ?? 0})`;
    }

    async function enrichCountsForOAP(roles){
      if(currentKey !== "oap" || !roles) return;
      for(const r of roles){
        if(!r.route) continue;
        try{
          const res = await fetch(`${DATA_DIR}/${r.route}.json?cb=${Date.now()}`);
          const data = await res.json();
          const n = (data.after?.roles?.length ?? 0);
          const base = String(r.name).replace(/\s*\(\d+\)\s*$/,'').trim();
          nodes.update({ id:r.id, label:`${base} (${n})` });
        }catch(_){}
      }
    }

    function baseNetworkOptions(){ network.setOptions(baseOptions()); }

    function mountOAP(view="DESPUÉS"){
      MODE = view; clearAll(); baseNetworkOptions();
      const data = (view==="ANTES") ? orgBefore : orgAfter;
      const {title, person} = splitTitlePerson(data.label);
      JEFA_LABEL = title || JEFA_LABEL; if(person) JEFA_PERSON = person;

      mountBox(data.id, JEFA_LABEL, 0, { color:{ background:"#fff", border:accent() }, borderWidth:2 });
      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, 1); addEdge(data.id, r.id); });

      updateCountsUI(); enrichCountsForOAP(data.roles); stabilizeAndFit(160);
    }

    function addCountsToNodes(data){
      if(!data || !data.subroles) return;
      for(const parentId in data.subroles){
        const node = nodes.get(parentId); if(!node) continue;
        const n = data.subroles[parentId].length;
        const base = String(node.label||"").replace(/\s*\(\d+\s+roles?\)\s*$/,'').trim();
        nodes.update({ id: parentId, label: `${base} (${n} roles)` });
      }
    }

    function mountTeam(view="DESPUÉS"){
      MODE = view; clearAll(); baseNetworkOptions();
      const data = (view==="ANTES") ? orgBefore : orgAfter;

      mountBox(STICKY_ID, JEFA_LABEL, 0, { color:{ background:"#fff", border:accent() }, borderWidth:2 });

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountBox(TEAM_ROOT_ID, cleanPhase(data.label), 1); addEdge(STICKY_ID, TEAM_ROOT_ID);

      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, 2); addEdge(TEAM_ROOT_ID, r.id); });
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, LEADER_NODE_ID);
      addCountsToNodes(data);

      updateCountsUI(); stabilizeAndFit(160);
    }

    async function loadTeam(key){
      try{
        const res = await fetch(`${DATA_DIR}/${key}.json?cb=${Date.now()}`);
        const data = await res.json();
        const prefix = key.toUpperCase();

        function mapRoles(block){
          return (block.roles || []).map(r => ({
            id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
          }));
        }
        function mapSubroles(block){
          const out = {};
          if(block.subroles){
            for(const roleId in block.subroles){
              out[`${prefix}_${roleId}`] = block.subroles[roleId].map(sr=>({
                id:`${prefix}_${sr.id}`, name:sr.name, person:sr.person||"", planta:!!sr.planta
              }));
            }
          }
          return out;
        }

        LEADER_NODE_ID = data.meta?.leaderId ? `${prefix}_${data.meta.leaderId}` : null;

        orgBefore = { id:`ROOT_BEFORE_${prefix}`, label:data.before.label || `${data.meta?.equipo||key} – ANTES`, roles: mapRoles(data.before), subroles: mapSubroles(data.before) };
        orgAfter  = { id:`ROOT_AFTER_${prefix}`,  label:data.after.label  || `${data.meta?.equipo||key} – DESPUÉS`, roles: mapRoles(data.after),  subroles: mapSubroles(data.after) };

        if(key==="oap"){
          const {title, person} = splitTitlePerson(orgAfter.label);
          if(title) JEFA_LABEL = cleanPhase(title);
          if(person) JEFA_PERSON = person;
        }

        const nice = TEAM_LABELS[key] || (data.meta?.equipo || key);
        document.getElementById("title").textContent = `Transformación del equipo – ${nice}${data.meta?.titulo ? ` (${data.meta.titulo})` : ""}`;

        currentKey = key; sel.value = key;
        if(key==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS");
      }catch(err){
        console.error(err);
        setStatus("Error al cargar");
        alert(`No pude cargar ${DATA_DIR}/${key}.json`);
      }
    }

    /************ INTERACCIÓN ************/
    network.on("click", (p)=>{
      if(!p.nodes.length) return;
      const id = p.nodes[0];

      if(currentKey === "oap"){
        const data = (MODE==="ANTES") ? orgBefore : orgAfter;

        if(id===data.id){
          const sid = `${data.id}_S`;
          if (sidePersons.has(sid)){ removeSidePerson(data.id); } else { placeSidePersonForJefa(data.id); }

          if(expandedRoot.has(data.id)){
            (data.roles||[]).forEach(r=>{
              closeSubtree(r.id, data);
              removePerson(r.id);
              removeSidePerson(r.id);
              try{ edges.remove(`${data.id}-${r.id}`);}catch(_){}
              try{ nodes.remove(r.id);}catch(_){}
            });
            expandedRoot.delete(data.id);
          }else{
            (data.roles||[]).forEach(r=>{ if(!nodes.get(r.id)) mountBox(r.id, r.name, 1); addEdge(data.id, r.id); });
            expandedRoot.add(data.id);
          }
          stabilizeAndFit(120);
          return;
        }

        const role = (data.roles||[]).find(r=>r.id===id);
        if(role && role.route){ loadTeam(role.route); return; }
        if(role && !role.route){ nodes.update({ id: role.id, level: 2 }); togglePersonNode(role.id, role.person, 3, !!role.planta); stabilizeAndFit(120); }
        return;
      }

      const data = (MODE==="ANTES") ? orgBefore : orgAfter;

      if(id===STICKY_ID){
        const sid = `${STICKY_ID}_S`;
        if (sidePersons.has(sid)){ removeSidePerson(STICKY_ID); } else { placeSidePersonForJefa(STICKY_ID); }
        stabilizeAndFit(120);
        return;
      }

      if(id===TEAM_ROOT_ID){
        if(expandedRoot.has(TEAM_ROOT_ID)){
          (data.roles||[]).forEach(r=>{
            closeSubtree(r.id, data);
            removePerson(r.id);
            removeSidePerson(r.id);
            try{ edges.remove(`${TEAM_ROOT_ID}-${r.id}`);}catch(_){}
            try{ nodes.remove(r.id);}catch(_){}
          });
          expandedRoot.delete(TEAM_ROOT_ID);
        }else{
          (data.roles||[]).forEach(r=>{ if(!nodes.get(r.id)) mountBox(r.id, r.name, 2); addEdge(TEAM_ROOT_ID, r.id); });
          rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, LEADER_NODE_ID);
          expandedRoot.add(TEAM_ROOT_ID);
        }
        stabilizeAndFit(120);
        return;
      }

      const role = (data.roles||[]).find(r=>r.id===id);
      if(role){
        if (role.id === LEADER_NODE_ID){
          const sid = `${role.id}_S`;
          if (sidePersons.has(sid)){ removeSidePerson(role.id); }
          else { placeSidePersonFor(role.id, (role.person||"Nuevo perfil"), SIDE_OFFSET); }

          const arr = data.subroles?.[role.id];
          if(arr && arr.length) toggleSubroles(role.id, arr, data);
        }else{
          togglePersonNode(role.id, role.person, 3, !!role.planta);
          const arr = data.subroles?.[role.id];
          if(arr && arr.length) toggleSubroles(role.id, arr, data);
        }
        stabilizeAndFit(120);
        return;
      }

      const nested = getSubrolesArr(data, id);
      if (nested && nested.length){
        toggleSubroles(id, nested, data);
        stabilizeAndFit(120);
        return;
      }
    });

    /************ SELECTOR Y BOTONES ************/
    sel.addEventListener("change", e=>loadTeam(e.target.value));
    document.getElementById("btnAntes").onclick   = ()=>{ if(currentKey==="oap") mountOAP("ANTES"); else mountTeam("ANTES"); document.querySelector('#btnAntes').classList.add('active'); document.querySelector('#btnDespues').classList.remove('active'); document.body.classList.add('mode-antes'); document.body.classList.remove('mode-despues'); };
    document.getElementById("btnDespues").onclick = ()=>{ if(currentKey==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS"); document.querySelector('#btnDespues').classList.add('active'); document.querySelector('#btnAntes').classList.remove('active'); document.body.classList.add('mode-despues'); document.body.classList.remove('mode-antes'); };

    /************ INICIO ************/
    loadTeam(currentKey);
  </script>
</body>
</html>



<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Organigramas OAP – Antes / Después</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    :root{
      /* Paleta y tokens visuales */
      --accent:#7c3aed;          /* Indigo 600 */
      --accent-antes:#6b21a8;    /* Purple 800 para ANTES */
      --ink:#0f172a;
      --muted:#6b7280;
      --border:#e6e7ef;
      --bg:#ffffff;
      --appbar-bg: linear-gradient(180deg,#f6f4ff 0%, #f1effe 100%);

      --node-bg:#ffffff;
      --node-border:#d3d6e4;
      --leader-bg:#f4f1ff;
      --leader-border:#7c3aed;

      /* KPIs / Drawer */
      --kpi-bg:#ffffff;
      --kpi-border:#e9e9f4;
      --kpi-sub:#6b7280;

      --drawer-bg:#ffffff;
      --drawer-w: 420px;
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--ink)}

    header{position:sticky; top:0; z-index:10; background:var(--appbar-bg); border-bottom:1px solid var(--border)}
    .appbar{max-width:1200px; margin:0 auto; padding:18px 20px; display:flex; align-items:center; gap:24px;}
    .appbar__brand{min-width:0}
    .appbar h1{margin:0; font-size:1.28rem; line-height:1.25; font-weight:800; letter-spacing:.2px}
    .appbar .subtitle{margin:6px 0 0; color:var(--muted); font-size:.95rem}
    .appbar__controls{margin-left:auto; display:flex; align-items:center; gap:14px; flex-wrap:wrap}

    label{font-size:.92rem; color:var(--muted)}
    select{padding:9px 12px; border:1px solid #dadcee; background:#fff; border-radius:12px; cursor:pointer; font-size:.95rem; box-shadow:0 1px 0 rgba(0,0,0,.02);}

    .btn-group{display:flex; gap:8px; white-space:nowrap}
    .btn{--btn-accent: var(--accent); appearance:none; border:none; outline:none; cursor:pointer;
      padding:9px 14px; border-radius:999px; font-weight:600; font-size:.95rem;
      background:#fff; color:#111; border:1px solid #dadcee; box-shadow:0 1px 0 rgba(0,0,0,.02); transition:.18s ease;}
    .btn:hover{transform:translateY(-1px)}
    .btn.active{background:var(--btn-accent); color:#fff; border-color:var(--btn-accent); box-shadow:0 6px 16px rgba(124,58,237,.25);}

    .hintwrap{background:var(--appbar-bg); border-bottom:1px solid var(--border)}
    .hint{max-width:1200px; margin:0 auto; padding:8px 20px 16px; color:var(--muted); font-size:.95rem; display:flex; align-items:center; justify-content:space-between;}
    .hint .actions{display:flex; gap:10px}

    /* KPIs fila */
    .kpi-wrap{max-width:1200px; margin:10px auto 0; padding:0 20px;}
    .kpi-grid{display:grid; grid-template-columns:repeat(6,minmax(0,1fr)); gap:10px;}
    .kpi{background:var(--kpi-bg); border:1px solid var(--kpi-border); border-radius:14px; padding:12px 14px; box-shadow:0 2px 8px rgba(0,0,0,.03);}
    .kpi .label{font-size:.86rem; color:var(--kpi-sub); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .kpi .value{display:flex; align-items:baseline; gap:8px; margin-top:6px}
    .kpi .num{font-size:1.35rem; font-weight:800}
    .kpi .delta{font-size:.85rem; padding:2px 8px; border-radius:999px; border:1px solid #eae7ff; color:#4f46e5; background:#f5f3ff}
    .kpi.total{grid-column: span 2}
    @media (max-width:1100px){ .kpi-grid{grid-template-columns:repeat(3,1fr)} .kpi.total{grid-column: span 3}}
    @media (max-width:700px){ .kpi-grid{grid-template-columns:repeat(2,1fr)} .kpi.total{grid-column: span 2}}

    /* Canvas con un grid sutil */
    #network{
      height:70vh;
      background:
        linear-gradient(transparent 31px,#f4f5fb 32px) repeat-y,
        linear-gradient(90deg,transparent 31px,#f4f5fb 32px) repeat-x;
      background-size:32px 32px,32px 32px;
    }

    #status{ display:none; }
    body.mode-antes  { --accent: var(--accent-antes); }
    body.mode-despues{ --accent: #7c3aed; }

    /* Drawer lateral derecho */
    .drawer-backdrop{
      position:fixed; inset:0; background:rgba(2,6,23,.28);
      opacity:0; pointer-events:none; transition:.18s ease all; z-index:30;
    }
    .drawer{
      position:fixed; top:0; right:-var(--drawer-w); width:var(--drawer-w); height:100vh; background:var(--drawer-bg);
      border-left:1px solid var(--border); box-shadow:-12px 0 30px rgba(0,0,0,.1); transition:.22s ease right; z-index:31; display:flex; flex-direction:column;
    }
    .drawer.open{ right:0 }
    .drawer-backdrop.open{ opacity:1; pointer-events:auto }
    .drawer header{display:flex; align-items:center; justify-content:space-between; padding:14px 14px; border-bottom:1px solid var(--border); background:#fff}
    .drawer h3{margin:0; font-size:1.05rem}
    .drawer .content{padding:10px 14px; overflow:auto}
    .drawer .tabs{display:flex; gap:8px; margin-left:auto}
    .drawer .tabs .seg{padding:6px 10px; border:1px solid #dadcee; background:#fff; border-radius:8px; font-weight:600; cursor:pointer}
    .drawer .tabs .seg.active{border-color:var(--accent); color:var(--accent); background:#fff}
    .chart-box{border:1px solid var(--border); border-radius:12px; padding:10px; background:#fff; margin-bottom:10px}
    .mini-note{font-size:.85rem; color:var(--muted)}
    table.summary{width:100%; border-collapse:separate; border-spacing:0; font-size:.94rem; border:1px solid var(--border); border-radius:12px; overflow:hidden}
    .summary th,.summary td{padding:8px 10px; border-bottom:1px solid #eee}
    .summary th{background:#fafafa; text-align:left}
    .summary tr.group td{background:#f4f1ff; font-weight:700}
  </style>
</head>
<body class="mode-despues">
  <header>
    <div class="appbar">
      <div class="appbar__brand">
        <h1 id="title">Organigrama del equipo de la Oficina Asesora de Planeación (OAP) – <span id="year"></span></h1>
        <p class="subtitle">Presentación institucional</p>
      </div>

      <div class="appbar__controls">
        <label>Equipo:
          <select id="teamSelect"></select>
        </label>
        <div class="btn-group">
          <button id="btnAntes" class="btn">Antes</button>
          <button id="btnDespues" class="btn active">Después</button>
        </div>
        <button id="openDrawer" class="btn" title="Ver resumen">Resumen</button>
        <span id="status">Listo</span>
      </div>
    </div>
    <div class="hintwrap">
      <div class="hint">
        <span>Usa la <b>raíz</b> para desplegar niveles y un <b>rol</b> para ver personas y subroles. En <b>OAP</b>, al hacer clic en un equipo se abre su subdiagrama.</span>
        <div class="actions">
          <button id="openDrawer2" class="btn">Resumen</button>
        </div>
      </div>
    </div>
  </header>

  <!-- KPIs -->
  <div class="kpi-wrap">
    <div id="kpiGrid" class="kpi-grid">
      <!-- se inyectan KPIs -->
    </div>
  </div>

  <div id="network"></div>

  <!-- Drawer -->
  <div id="drawerBackdrop" class="drawer-backdrop"></div>
  <aside id="drawer" class="drawer" aria-label="Resumen por equipos">
    <header>
      <h3 id="drawerTitle">Resumen — OAP General</h3>
      <div class="tabs" role="tablist" aria-label="Modo del resumen">
        <button class="seg" data-tab="ANTES">Antes</button>
        <button class="seg active" data-tab="DESPUÉS">Después</button>
        <button class="seg" data-tab="COMPARE">Comparar</button>
        <button id="closeDrawer" class="btn" style="margin-left:8px">Cerrar</button>
      </div>
    </header>
    <div class="content">
      <div class="chart-box">
        <canvas id="resumenChart" width="380" height="280" aria-label="Gráfica comparativa"></canvas>
        <div class="mini-note" id="chartNote"></div>
      </div>
      <table class="summary" id="drawerTable">
        <!-- cuerpo se inyecta -->
      </table>
    </div>
  </aside>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const statusEl = document.getElementById("status");
    function setStatus(msg){ if(statusEl) statusEl.textContent = msg; }
    window.addEventListener("error", (e)=>{ console.error(e.error || e.message); setStatus("Error: " + (e.error?.message || e.message)); });

    const DATA_DIR = "data";
    const TEAMS = ["oap","4p","gestion_conocimiento","administrativo","ti","mipg"];
    const TEAM_LABELS = { oap:"OAP General","4p":"4P",gestion_conocimiento:"Gestión del Conocimiento",administrativo:"Administrativo",ti:"TI",mipg:"MIPG" };

    const sel = document.getElementById("teamSelect");
    sel.innerHTML = TEAMS.map(k=>`<option value="${k}">${TEAM_LABELS[k]||k.toUpperCase()}</option>`).join("");
    sel.value = "oap";

    /* ================== CONTEOS MANUALES (OAP General) ================== */
    const OAP_MANUAL_COUNTS = {
      "ANTES": { "4p": 6, "ti": 19, "gestion_conocimiento": 3, "mipg": 8, "administrativo": 8 },
      "DESPUÉS": { "4p": 8, "ti": 20, "gestion_conocimiento": 3, "mipg": 6, "administrativo": 6 }
    };

    const TEAM_FIXED_COUNTS = { /* opcional */ };

    const LEVEL_Y_GAP = 130;
    const MIN_GAP = 300;

    let currentKey = "oap";
    let MODE = "DESPUÉS";
    let orgBefore = null, orgAfter = null;

    let JEFA_LABEL = "Jefa OAP";
    let JEFA_PERSON = "";
    const STICKY_ID = "GLOBAL_OAP_JEFA";
    let TEAM_ROOT_ID = null;

    /* líderes por modo */
    let LEADER_NODE_ID_BEFORE = null;
    let LEADER_NODE_ID_AFTER  = null;

    /* Analista estratégica (solo OAP) */
    const STRATEGIST_ID = "OAP_STRATEGIST";
    let STRATEGIST = null;

    const SIDE_OFFSET = 220;
    const JEFA_SIDE_OFFSET = 220;

    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();
    const network = new vis.Network(
      document.getElementById("network"),
      { nodes, edges },
      baseOptions()
    );

    network.setOptions({
      nodes:{
        chosen:{
          node: (values)=>{
            values.shadow = true;
            values.shadowSize = 28;
            values.shadowColor = "rgba(124,58,237,.20)";
            values.borderWidth = 2;
            values.color = values.color || {};
            values.color.border = getComputedStyle(document.body).getPropertyValue('--accent').trim();
          }
        }
      },
      edges:{
        chosen:{
          edge: (values)=>{ values.width = 2; values.color = getComputedStyle(document.body).getPropertyValue('--accent').trim(); }
        }
      }
    });

    const expandedRoot  = new Set();
    const openedPersons = new Set();
    const openedSubroles = new Set();
    const sidePersons   = new Set();

    /* IDs de las líneas punteadas estratega → equipos (solo OAP) */
    const dottedArcIds = new Set();

    function baseOptions(){
      return {
        layout: { hierarchical: {
          enabled:true, direction:"UD",
          levelSeparation: LEVEL_Y_GAP, nodeSpacing: MIN_GAP,
          parentCentralization:true, blockShifting:false, edgeMinimization:true,
          sortMethod:"directed"
        }},
        physics:false,
        nodes:{
          shape:"box",
          margin:10,
          borderWidth:1,
          color:{ background:getComputedStyle(document.body).getPropertyValue('--node-bg').trim(),
                  border:getComputedStyle(document.body).getPropertyValue('--node-border').trim() },
          font:{ size:14, face:"system-ui, Segoe UI, Roboto, Arial, sans-serif", color:"#111827" },
          shadow:{ enabled:true, color:"rgba(0,0,0,.08)", size:20, x:0, y:6 },
          shapeProperties:{ borderRadius:12 }
        },
        edges:{
          color:{ color:'#cfd5e3', highlight:'#a7b0c6' },
          width:1.2,
          smooth:{ enabled:true, type:"cubicBezier", forceDirection:"vertical", roundness:0.5 }
        },
        interaction:{ hover:true, selectable:true, dragNodes:false, zoomView:true, dragView:true, tooltipDelay:100 }
      };
    }

    const accent = ()=> getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#7c3aed';
    const cleanPhase = (lbl='') => lbl.replace(/\s*[-–]\s*(ANTES|DESPUÉS)\s*$/i,'').replace(/\s*\((ANTES|DESPUÉS)\)\s*$/i,'').trim();

    function stripTrailingCount(s){ return String(s).replace(/\s*\(\s*\d+\s*(?:roles?)?\s*\)\s*$/i,'').trim(); }

    function splitTitlePerson(lbl){
      if(!lbl) return {title:"", person:""};
      const base = cleanPhase(lbl);
      const m = base.match(/^(.+?)\s*[–-]\s*(.+)$/);
      return m ? { title:m[1].trim(), person:m[2].trim() } : { title:base, person:"" };
    }

    function clearAll(){
      nodes.clear(); edges.clear();
      expandedRoot.clear(); openedPersons.clear();
      openedSubroles.clear(); sidePersons.clear(); dottedArcIds.clear();
    }
    function mountBox(id, label, level, extra={}){ nodes.add(Object.assign({ id, label, level, shape:"box", color:{ background:"#fff", border:"#9aa3af" }, borderWidth:1 }, extra)); }
    function addEdge(from, to, extra={}){ const id = `${from}-${to}`; if(!edges.get(id)) edges.add(Object.assign({ id, from, to }, extra)); return id; }
    function getLevel(nodeId){ const n = nodes.get(nodeId); return (n && typeof n.level === 'number') ? n.level : null; }
    function getSubrolesArr(data, nodeId){ return (data && data.subroles && data.subroles[nodeId]) ? data.subroles[nodeId] : null; }

    function removePerson(parentId){
      const pid = `${parentId}_P`;
      if (openedPersons.has(pid)){ try{ nodes.remove(pid);}catch(_){} try{ edges.remove(`${parentId}-${pid}`);}catch(_){} openedPersons.delete(pid); }
    }
    function removeSidePerson(parentId){
      const sid = `${parentId}_S`;
      if (sidePersons.has(sid)){ try{ nodes.remove(sid);}catch(_){} try{ edges.remove(`${parentId}-${sid}`);}catch(_){} sidePersons.delete(sid); }
    }
    function closeSubtree(nodeId, data){
      const children = getSubrolesArr(data, nodeId) || [];
      children.forEach(ch => {
        closeSubtree(ch.id, data);
        removePerson(ch.id); removeSidePerson(ch.id);
        try{ edges.remove(`${nodeId}-${ch.id}`);}catch(_){}
        try{ nodes.remove(ch.id);}catch(_){}
        openedSubroles.delete(ch.id);
      });
      openedSubroles.delete(nodeId);
    }

    /* ------ Layout helpers ------ */
    function applyVerticalByLevel(y0=0){
      const all = nodes.get();
      nodes.update(all.map(n =>
        (typeof n.level==='number')
          ? { id:n.id, y: y0 + n.level*LEVEL_Y_GAP }
          : { id:n.id }
      ));
    }
    function childrenOf(parentId){
      return edges.get({ filter: e => e.from === parentId }).map(e => e.to).filter(id => !!nodes.get(id));
    }
    function spreadChildren(parentId, gap = MIN_GAP){
      const kids = childrenOf(parentId); if(kids.length < 2) return;
      const p = network.getPositions([parentId])[parentId] || {x:0,y:0};
      const posKids = network.getPositions(kids);
      kids.sort((a,b) => (posKids[a]?.x || 0) - (posKids[b]?.x || 0));
      const total = (kids.length - 1) * gap; let startX = p.x - total / 2;
      nodes.update(kids.map((id, i) => ({ id, x: Math.round(startX + i * gap) })));
    }
    function applyHorizontalSpacingAll(gap=MIN_GAP){
      const parents = Array.from(new Set(edges.get().map(e => e.from)));
      parents.sort((a,b) => ((nodes.get(a)?.level||0) - (nodes.get(b)?.level||0)));
      parents.forEach(pid => spreadChildren(pid, gap));
    }
    function fixAllPositions(fix=true){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:fix, y:fix } }))); }
    function unfixAllPositions(){ nodes.update(nodes.get().map(n => ({ id:n.id, fixed:{ x:false, y:false } }))); }

    function placeSidePersonFor(rootId, label, offset = SIDE_OFFSET){
      if (!label || !label.trim()) return;
      const sid = `${rootId}_S`;
      const rootNode = nodes.get(rootId); if(!rootNode) return;
      if (!nodes.get(sid)){
        mountBox(sid, label.trim(), rootNode.level, {
          font:{ italics:true, color:"#374151" },
          color:{ background:"#f8fafc", border:"#d1d5db" },
          shapeProperties:{ borderRadius:999 }
        });
        addEdge(rootId, sid, { dashes:true, arrows:'to', smooth:{ enabled:true, type:'horizontal', forceDirection:'vertical' } });
        sidePersons.add(sid);
      }
      const r = network.getPositions([rootId])[rootId] || {x:0,y:0};
      nodes.update({ id: sid, x: r.x + offset, y: r.y, level: rootNode.level, fixed:{ x:true, y:true } });
    }
    function keepSideAligned(rootId, offset = SIDE_OFFSET){
      const sid = `${rootId}_S`;
      if (!nodes.get(sid) || !nodes.get(rootId)) return;
      const r = network.getPositions([rootId])[rootId];
      const level = getLevel(rootId) ?? 0;
      nodes.update({ id: sid, x: r.x + offset, y: r.y, level });
    }
    function placeSidePersonForJefa(rootId){ placeSidePersonFor(rootId, JEFA_PERSON, JEFA_SIDE_OFFSET); }
    function keepJefaPersonSideAlignedFor(rootId){ keepSideAligned(rootId, JEFA_SIDE_OFFSET); }

    function clearDottedArcs(){ dottedArcIds.forEach(id => { try{ edges.remove(id);}catch(_){} }); dottedArcIds.clear(); }
    function buildDottedArcsToTeams(roles){
      clearDottedArcs();
      if (!STRATEGIST || !STRATEGIST.label || !nodes.get(STRATEGIST_ID)) return;
      (roles||[]).forEach(r=>{
        if(!nodes.get(r.id)) return;
        const id = `DOT_${STRATEGIST_ID}_${r.id}`;
        edges.add({ id, from: STRATEGIST_ID, to: r.id, dashes: true, arrows: '', color:{color:'#9aa3b2'}, width:1.6,
          smooth:{ enabled:true, type:'horizontal', forceDirection:'vertical', roundness:0.35 }});
        dottedArcIds.add(id);
      });
    }

    function stabilizeAndFit(anim=200){
      setStatus("Ajustando layout…");
      unfixAllPositions();
      applyVerticalByLevel(0);
      setTimeout(() => {
        applyHorizontalSpacingAll(MIN_GAP);
        if (currentKey === 'oap'){
          if (nodes.get(orgAfter?.id || orgBefore?.id)) { nodes.update({ id:(MODE==="ANTES"?orgBefore.id:orgAfter.id), x: 0 }); }
          if (nodes.get(STRATEGIST_ID)) { nodes.update({ id: STRATEGIST_ID, x: 0 }); }
          keepJefaPersonSideAlignedFor((MODE==="ANTES") ? orgBefore.id : orgAfter.id);
          if (nodes.get(STRATEGIST_ID)) keepSideAligned(STRATEGIST_ID, SIDE_OFFSET);
        }
        setTimeout(() => {
          fixAllPositions(true);
          network.fit({ animation:{ duration: anim, easingFunction:"easeInOutQuad" } });
          setStatus("Listo");
        }, 0);
      }, 0);
    }

    function togglePersonNode(roleId, personLabel, levelIfUnknown, planta=false){
      const label = (personLabel || "").trim();
      if(!label) return;
      const pid = `${roleId}_P`;
      if(openedPersons.has(pid)){
        try{ nodes.remove(pid);}catch(_){}
        try{ edges.remove(`${roleId}-${pid}`);}catch(_){}
        openedPersons.delete(pid);
        return;
      }
      const roleLevel = getLevel(roleId);
      const personLevel = (roleLevel!=null ? roleLevel + 1 : (levelIfUnknown || 3));
      const extra = { font:{ italics:true } };
      if(planta) extra.color = { background:"#efe9ff", border:"#7a5cff" };
      mountBox(pid, label, personLevel, extra);
      addEdge(roleId, pid);
      openedPersons.add(pid);
    }

    function toggleSubroles(roleId, subrolesArr, dataCtx){
      if(!subrolesArr || !subrolesArr.length) return;
      if(openedSubroles.has(roleId)){
        subrolesArr.forEach(sr=>{
          const rid = sr.id, pid = `${rid}_P`;
          try{ nodes.remove(pid);}catch(_){}
          try{ edges.remove(`${rid}-${pid}`);}catch(_){}
          try{ nodes.remove(rid);}catch(_){}
          try{ edges.remove(`${roleId}-${rid}`);}catch(_){}
          openedPersons.delete(pid);
        });
        openedSubroles.delete(roleId);
        return;
      }
      const roleLevel = getLevel(roleId) ?? 3;

      const CURRENT_LEADER_ID = (MODE === "ANTES") ? LEADER_NODE_ID_BEFORE : LEADER_NODE_ID_AFTER;
      const isLeaderParent = (CURRENT_LEADER_ID && roleId === CURRENT_LEADER_ID);

      const subLevel = roleLevel + (isLeaderParent ? 2 : 1);
      const personLevel = subLevel + 1;

      subrolesArr.forEach(sr=>{
        mountBox(sr.id, sr.name, subLevel);
        addEdge(roleId, sr.id);
        const hasGrandkids = !!getSubrolesArr(dataCtx, sr.id)?.length;
        const personText = (sr.person || "").trim();
        if (personText){
          mountBox(`${sr.id}_P`, personText, personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`); openedPersons.add(`${sr.id}_P`);
        } else if (!hasGrandkids) {
          mountBox(`${sr.id}_P`, "Nuevo perfil", personLevel, { font:{ italics:true } });
          addEdge(sr.id, `${sr.id}_P`); openedPersons.add(`${sr.id}_P`);
        }
      });
      openedSubroles.add(roleId);
    }

    function rewireUnderLeaderIfAny(rootId, roles, leaderIdFromMeta){
      let leaderId = leaderIdFromMeta || null;
      if(!leaderId){
        const cand = roles.find(r=>/^\s*l[ií]der\s*$/i.test(r.name));
        leaderId = cand?.id || null;
      }
      if(!leaderId || !nodes.get(leaderId)) return;
      const base = getLevel(rootId) ?? 0;
      nodes.update({ id: leaderId, level: base + 1 });
      roles.forEach(r=>{
        if(r.id === leaderId) return;
        try{ edges.remove(`${rootId}-${r.id}`);}catch(_){}
        addEdge(leaderId, r.id);
        nodes.update({ id: r.id, level: base + 2 });
      });
    }

    function refreshButtons(){
      const a = document.getElementById("btnAntes");
      const d = document.getElementById("btnDespues");
      a.classList.toggle("active", MODE==="ANTES"); d.classList.toggle("active", MODE==="DESPUÉS");
      document.body.classList.toggle("mode-antes",   MODE==="ANTES");
      document.body.classList.toggle("mode-despues", MODE==="DESPUÉS");
      a.style.setProperty("--btn-accent","var(--accent)"); d.style.setProperty("--btn-accent","var(--accent)");
      renderKPIs(); // sincroniza KPIs
      if (isDrawerOpen()) renderDrawer(); // sincroniza drawer
    }

    function updateCountsUI(){}

    async function enrichCountsForOAP(roles){
      if(currentKey !== "oap" || !roles) return;
      const modeKey = (MODE === "ANTES") ? "ANTES" : "DESPUÉS";
      for (const r of (roles || [])){
        const baseLabel = stripTrailingCount(r.name);
        const routeKey  = (r.route || "").trim();
        const manual    = routeKey ? OAP_MANUAL_COUNTS[modeKey]?.[routeKey] : undefined;
        nodes.update({ id: r.id, label: typeof manual==="number" ? `${baseLabel} (${manual} roles)` : baseLabel });
      }
      buildDottedArcsToTeams(roles);
    }

    function baseNetworkOptions(){ network.setOptions(baseOptions()); }

    /* ===== OAP ===== */
    function mountOAP(view="DESPUÉS"){
      MODE = view; clearAll(); baseNetworkOptions(); refreshButtons();
      const data = (view==="ANTES") ? orgBefore : orgAfter;
      const {title, person} = splitTitlePerson(data.label);
      JEFA_LABEL = title || JEFA_LABEL; if(person) JEFA_PERSON = person;

      mountBox(data.id, JEFA_LABEL, 0, { color:{ background:"#fff", border:accent() }, borderWidth:2 });
      nodes.update({ id:data.id, x: 0 });

      const hasStrategist = !!(STRATEGIST && STRATEGIST.label);
      if (hasStrategist){
        mountBox(STRATEGIST_ID, STRATEGIST.label, 1);
        addEdge(data.id, STRATEGIST_ID);
        nodes.update({ id: STRATEGIST_ID, x: 0 });
      }
      const levelTeams = hasStrategist ? 2 : 1;
      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, levelTeams); addEdge(data.id, r.id); });

      enrichCountsForOAP(data.roles);
      stabilizeAndFit(160);
      renderKPIs();
    }

    function addCountsToNodes(data, overrides){
      if(!data || !data.subroles) return;
      for(const parentId in data.subroles){
        const node = nodes.get(parentId); if(!node) continue;
        const base = stripTrailingCount(node.label || "");
        const nOverride = overrides && overrides[base];
        const n = (nOverride != null) ? nOverride : data.subroles[parentId].length;
        nodes.update({ id: parentId, label: `${base} (${n} roles)` });
      }
    }

    function mountTeam(view="DESPUÉS"){
      MODE = view; baseNetworkOptions(); refreshButtons();
      clearAll();
      try{ nodes.remove(STICKY_ID); }catch(_){}
      try{
        edges.get().forEach(e=>{ if(e.from===STICKY_ID || e.to===STICKY_ID) edges.remove(e.id); });
      }catch(_){}
      const data = (view==="ANTES") ? orgBefore : orgAfter;

      TEAM_ROOT_ID = `TEAM_${currentKey.toUpperCase()}`;
      mountBox(TEAM_ROOT_ID, cleanPhase(data.label), 0);
      (data.roles || []).forEach(r=>{ mountBox(r.id, r.name, 1); addEdge(TEAM_ROOT_ID, r.id); });

      const CURRENT_LEADER_ID = (MODE === "ANTES") ? LEADER_NODE_ID_BEFORE : LEADER_NODE_ID_AFTER;
      rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, CURRENT_LEADER_ID);
      if (CURRENT_LEADER_ID && nodes.get(CURRENT_LEADER_ID)) {
        nodes.update({
          id: CURRENT_LEADER_ID,
          color:{ background:getComputedStyle(document.body).getPropertyValue('--leader-bg').trim(),
                  border: getComputedStyle(document.body).getPropertyValue('--leader-border').trim() },
          font:{ bold:true }
        });
      }

      const teamOverrides =
        (TEAM_FIXED_COUNTS[currentKey] && TEAM_FIXED_COUNTS[currentKey][(MODE==="ANTES") ? "ANTES" : "DESPUÉS"]) || null;
      addCountsToNodes(data, teamOverrides);

      stabilizeAndFit(160);
      renderKPIs();
      if (isDrawerOpen()) renderDrawer();
    }

    async function loadTeam(key){
      setStatus("Cargando…");
      try{
        const res = await fetch(`${DATA_DIR}/${key}.json?cb=${Date.now()}`);
        const data = await res.json();
        const prefix = key.toUpperCase();

        function mapRoles(block){
          return (block.roles || []).map(r => ({
            id:`${prefix}_${r.id}`, name:r.name, person:r.person||"", planta:!!r.planta, route:r.route||""
          }));
        }
        function mapSubroles(block){
          const out = {};
          if(block.subroles){
            for(const roleId in block.subroles){
              out[`${prefix}_${roleId}`] = block.subroles[roleId].map(sr=>({
                id:`${prefix}_${sr.id}`, name:sr.name, person:sr.person||"", planta:!!sr.planta
              }));
            }
          }
          return out;
        }

        LEADER_NODE_ID_BEFORE = data.meta?.leaderIdBefore ? `${prefix}_${data.meta.leaderIdBefore}` : null;
        LEADER_NODE_ID_AFTER  = data.meta?.leaderIdAfter  ? `${prefix}_${data.meta.leaderIdAfter}`  : null;
        if (data.meta?.leaderId) {
          const fallback = `${prefix}_${data.meta.leaderId}`;
          if (!LEADER_NODE_ID_BEFORE) LEADER_NODE_ID_BEFORE = fallback;
          if (!LEADER_NODE_ID_AFTER)  LEADER_NODE_ID_AFTER  = fallback;
        }

        STRATEGIST = data.meta?.strategist
          ? { label: (data.meta.strategist.label||"").trim(), person: (data.meta.strategist.person||"").trim() }
          : null;

        orgBefore = { id:`ROOT_BEFORE_${prefix}`, label:data.before.label || `${data.meta?.equipo||key} – ANTES`, roles: mapRoles(data.before), subroles: mapSubroles(data.before) };
        orgAfter  = { id:`ROOT_AFTER_${prefix}`,  label:data.after.label  || `${data.meta?.equipo||key} – DESPUÉS`, roles: mapRoles(data.after),  subroles: mapSubroles(data.after) };

        if(key==="oap"){
          const {title, person} = splitTitlePerson(orgAfter.label);
          if(title) JEFA_LABEL = cleanPhase(title);
          if(person) JEFA_PERSON = person;
        }

        document.getElementById("title").innerHTML =
          `Organigrama del equipo de la Oficina Asesora de Planeación (OAP) – <span id="year">${new Date().getFullYear()}</span>`;

        currentKey = key; sel.value = key;
        if(key==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS");
        setStatus("Listo");
      }catch(err){
        console.error(err);
        setStatus("Error al cargar");
        alert(`No pude cargar ${DATA_DIR}/${key}.json`);
      }
    }

    /* -------- Interacción organigrama -------- */
    network.on("click", (p)=>{
      if(!p.nodes.length) return;
      const id = p.nodes[0];

      if(currentKey === "oap"){
        const data = (MODE==="ANTES") ? orgBefore : orgAfter;

        if(id===data.id){
          const sid = `${data.id}_S`;
          if (sidePersons.has(sid)){ removeSidePerson(data.id); } else { placeSidePersonForJefa(data.id); }

          if(expandedRoot.has(data.id)){
            (data.roles||[]).forEach(r=>{
              closeSubtree(r.id, data);
              removePerson(r.id); removeSidePerson(r.id);
              try{ edges.remove(`${data.id}-${r.id}`);}catch(_){}
              try{ nodes.remove(r.id);}catch(_){}
            });
            if (nodes.get(STRATEGIST_ID)){
              removePerson(STRATEGIST_ID);
              try{ edges.remove(`${data.id}-${STRATEGIST_ID}`);}catch(_){}
              try{ nodes.remove(STRATEGIST_ID);}catch(_){}
            }
            clearDottedArcs();
            expandedRoot.delete(data.id);
          }else{
            if (STRATEGIST && STRATEGIST.label && !nodes.get(STRATEGIST_ID)){
              mountBox(STRATEGIST_ID, STRATEGIST.label, 1);
              addEdge(data.id, STRATEGIST_ID);
              nodes.update({ id: STRATEGIST_ID, x: 0 });
            }
            const levelTeams = (STRATEGIST && STRATEGIST.label) ? 2 : 1;
            (data.roles||[]).forEach(r=>{
              if(!nodes.get(r.id)) mountBox(r.id, r.name, levelTeams);
              addEdge(data.id, r.id);
            });
            buildDottedArcsToTeams(data.roles);
            expandedRoot.add(data.id);
          }
          stabilizeAndFit(120);
          return;
        }

        if (id === STRATEGIST_ID){
          togglePersonNode(STRATEGIST_ID, STRATEGIST?.person || "", 2, false);
          nodes.update({ id: STRATEGIST_ID, x: 0 });
          stabilizeAndFit(120);
          return;
        }

        const role = (data.roles||[]).find(r=>r.id===id);
        if(role && role.route){ loadTeam(role.route); return; }
        if(role && !role.route){ togglePersonNode(role.id, role.person, 3, !!role.planta); stabilizeAndFit(120); }
        return;
      }

      /* Vista equipo */
      const data = (MODE==="ANTES") ? orgBefore : orgAfter;

      if(id===TEAM_ROOT_ID){
        if(expandedRoot.has(TEAM_ROOT_ID)){
          (data.roles||[]).forEach(r=>{
            closeSubtree(r.id, data); removePerson(r.id); removeSidePerson(r.id);
            try{ edges.remove(`${TEAM_ROOT_ID}-${r.id}`);}catch(_){}
            try{ nodes.remove(r.id);}catch(_){}
          });
          expandedRoot.delete(TEAM_ROOT_ID);
        }else{
          (data.roles||[]).forEach(r=>{
            if(!nodes.get(r.id)) mountBox(r.id, r.name, 1);
            addEdge(TEAM_ROOT_ID, r.id);
          });
          const CURRENT_LEADER_ID = (MODE === "ANTES") ? LEADER_NODE_ID_BEFORE : LEADER_NODE_ID_AFTER;
          rewireUnderLeaderIfAny(TEAM_ROOT_ID, data.roles, CURRENT_LEADER_ID);
          expandedRoot.add(TEAM_ROOT_ID);
        }
        stabilizeAndFit(120);
        return;
      }

      const role = (data.roles||[]).find(r=>r.id===id);
      if(role){
        const CURRENT_LEADER_ID = (MODE === "ANTES") ? LEADER_NODE_ID_BEFORE : LEADER_NODE_ID_AFTER;
        if (role.id === CURRENT_LEADER_ID){
          const sid = `${role.id}_S`;
          if (sidePersons.has(sid)){ removeSidePerson(role.id); }
          else { placeSidePersonFor(role.id, (role.person||"Nuevo perfil"), SIDE_OFFSET); }
          const arr = data.subroles?.[role.id];
          if(arr && arr.length) toggleSubroles(role.id, arr, data);
        }else{
          togglePersonNode(role.id, role.person, 3, !!role.planta);
          const arr = data.subroles?.[role.id];
          if(arr && arr.length) toggleSubroles(role.id, arr, data);
        }
        stabilizeAndFit(120);
        return;
      }

      const nested = getSubrolesArr(data, id);
      if (nested && nested.length){
        toggleSubroles(id, nested, data);
        stabilizeAndFit(120);
        return;
      }
    });

    /* ======= Resumen: KPIs + Drawer ======= */
    let resumenData = null;
    let drawerMode = 'DESPUÉS'; // ANTES | DESPUÉS | COMPARE

    async function ensureResumen(){
      if (resumenData) return resumenData;
      const res = await fetch(`${DATA_DIR}/resumen.json?cb=${Date.now()}`);
      resumenData = await res.json();
      return resumenData;
    }

    function scopeKeys(){
      return (currentKey==='oap')
        ? ['4p','ti','gestion_conocimiento','mipg','administrativo']
        : [currentKey];
    }

    function getEquipo(equipokey){ return resumenData?.equipos?.[equipokey] || null; }
    function val(e, mode){ return mode==='ANTES' ? (e?.antes?.total||0) : (e?.despues?.total||0); }
    function nota(e, mode){ return mode==='ANTES' ? (e?.antes?.nota||'') : (e?.despues?.nota||''); }

    function sumScope(mode){
      return scopeKeys().reduce((acc,k)=> acc + (val(getEquipo(k), mode) || 0), 0);
    }

    function renderKPIs(){
      const grid = document.getElementById('kpiGrid');
      if(!resumenData){ grid.innerHTML=''; return; }
      const keys = scopeKeys();
      const mode = MODE; // sincronizamos KPIs con el modo del organigrama
      const total = sumScope(mode);
      const totalAntes = sumScope('ANTES');
      const totalDesp = sumScope('DESPUÉS');
      const delta = totalDesp - totalAntes;
      const deltaTxt = (delta===0) ? 'sin cambio' : (delta>0 ? `+${delta}` : `${delta}`);

      let html = `
        <div class="kpi total">
          <div class="label">Total ${TEAM_LABELS[currentKey]||currentKey.toUpperCase()}</div>
          <div class="value"><span class="num">${total}</span><span class="delta">${deltaTxt}</span></div>
        </div>
      `;
      keys.forEach(k=>{
        const e = getEquipo(k);
        if(!e) return;
        const n = val(e, mode);
        const d = (e?.despues?.total||0) - (e?.antes?.total||0);
        const dTxt = (d===0) ? '0' : (d>0?`+${d}`:`${d}`);
        html += `
          <div class="kpi">
            <div class="label">${e.label || (TEAM_LABELS[k]||k.toUpperCase())}</div>
            <div class="value"><span class="num">${n}</span><span class="delta">${dTxt}</span></div>
          </div>
        `;
      });
      grid.innerHTML = html;
    }

    function isDrawerOpen(){ return document.getElementById('drawer').classList.contains('open'); }
    function openDrawer(){ document.getElementById('drawer').classList.add('open'); document.getElementById('drawerBackdrop').classList.add('open'); renderDrawer(); }
    function closeDrawer(){ document.getElementById('drawer').classList.remove('open'); document.getElementById('drawerBackdrop').classList.remove('open'); }

    function drawChart(){
      const canvas = document.getElementById('resumenChart');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const keys = scopeKeys();
      const labels = keys.map(k=> getEquipo(k)?.label || (TEAM_LABELS[k]||k.toUpperCase()));
      const A = keys.map(k=> getEquipo(k)?.antes?.total || 0);
      const D = keys.map(k=> getEquipo(k)?.despues?.total || 0);
      const maxv = Math.max(1, ...A, ...D);

      const left = 120, right = 20, top = 20, rowH = 34, gap = 10;
      const barH = 10;

      labels.forEach((lab, i)=>{
        const y = top + i*(rowH+gap) + 8;
        ctx.fillStyle='#111827';
        ctx.font='12px system-ui';
        ctx.textAlign='right';
        ctx.fillText(lab, left-8, y+barH);

        const drawBar = (val, yoff, isA)=>{
          const w = ((canvas.width-left-right) * val) / maxv;
          ctx.fillStyle = isA ? '#a78bfa' : '#7c3aed';
          ctx.fillRect(left, y+yoff, w, barH);
          ctx.fillStyle='#111827';
          ctx.textAlign='left';
          ctx.fillText(val, left + w + 6, y+yoff+barH);
        };
        if (drawerMode==='COMPARE'){ drawBar(A[i], 0, true); drawBar(D[i], barH+4, false); }
        else if (drawerMode==='ANTES'){ drawBar(A[i], 0, true); }
        else { drawBar(D[i], 0, false); }
      });

      const note = document.getElementById('chartNote');
      if (drawerMode==='COMPARE') note.textContent = 'Comparativo por equipo (Antes vs Después)';
      else note.textContent = `Vista ${drawerMode.toLowerCase()}`;
    }

    function renderTable(){
      const t = document.getElementById('drawerTable');
      const keys = scopeKeys();
      const compare = (drawerMode==='COMPARE');
      let html = `
        <thead>
          <tr>
            <th style="width:58%">Equipos / subdivisiones</th>
            ${compare ? '<th>Antes</th><th>Después</th>' : `<th>${drawerMode[0]}${drawerMode.slice(1).toLowerCase()}</th>`}
          </tr>
        </thead>
        <tbody>
      `;
      let totA = 0, totD = 0;
      keys.forEach(k=>{
        const e = getEquipo(k); if(!e) return;
        const la = e?.antes?.total || 0, ld = e?.despues?.total || 0;
        totA += la; totD += ld;
        html += `<tr class="group">
          <td>${e.label || (TEAM_LABELS[k]||k.toUpperCase())}</td>
          ${compare ? `<td>${la}${e?.antes?.nota?` <span class="mini-note">${e.antes.nota}</span>`:''}</td><td>${ld}${e?.despues?.nota?` <span class="mini-note">${e.despues.nota}</span>`:''}</td>`
                   : `<td>${drawerMode==='ANTES'?la:ld}${(drawerMode==='ANTES'?e?.antes?.nota:e?.despues?.nota)?` <span class="mini-note">${drawerMode==='ANTES'?e.antes.nota:e.despues.nota}</span>`:''}</td>`}
        </tr>`;
        (e.subdivisiones||[]).forEach(s=>{
          html += `<tr>
            <td>${s.label}</td>
            ${compare ? `<td>${s.antes??'—'}</td><td>${s.despues??'—'}</td>`
                     : `<td>${drawerMode==='ANTES' ? (s.antes??'—') : (s.despues??'—')}</td>`}
          </tr>`;
        });
      });
      html += `</tbody>`;
      html += `<tfoot><tr>
        <th style="text-align:right">Total</th>
        ${compare ? `<th>${totA}</th><th>${totD}</th>` : `<th>${drawerMode==='ANTES'?totA:totD}</th>`}
      </tr></tfoot>`;
      t.innerHTML = html;
    }

    async function renderDrawer(){
      await ensureResumen();
      document.getElementById('drawerTitle').textContent = `Resumen — ${TEAM_LABELS[currentKey]||currentKey.toUpperCase()}`;
      drawChart();
      renderTable();
    }

    /* Eventos Drawer */
    document.getElementById('openDrawer').onclick = async ()=>{ await ensureResumen(); openDrawer(); };
    document.getElementById('openDrawer2').onclick = async ()=>{ await ensureResumen(); openDrawer(); };
    document.getElementById('closeDrawer').onclick = closeDrawer;
    document.getElementById('drawerBackdrop').onclick = closeDrawer;

    document.querySelectorAll('.drawer .seg').forEach(b=>{
      b.addEventListener('click', ()=>{
        document.querySelectorAll('.drawer .seg').forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        drawerMode = b.dataset.tab;
        renderDrawer();
      });
    });

    /* Cambio de equipo y modo */
    sel.addEventListener("change", async e=>{
      await loadTeam(e.target.value);
      renderKPIs();
      if (isDrawerOpen()) renderDrawer();
    });
    document.getElementById("btnAntes").onclick   = ()=>{ if(currentKey==="oap") mountOAP("ANTES"); else mountTeam("ANTES"); };
    document.getElementById("btnDespues").onclick = ()=>{ if(currentKey==="oap") mountOAP("DESPUÉS"); else mountTeam("DESPUÉS"); };

    /* ===== Carga inicial ===== */
    (async function init(){
      await ensureResumen();
      await loadTeam("oap");
      renderKPIs();
    })();
  </script>
</body>
</html>



